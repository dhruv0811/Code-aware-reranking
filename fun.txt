Random number:  9776
Initializing Embedding Model...
Corpus loaded!
Retrieved Documents:  ['from typing import List\n\n\ndef func_0(numbers: List[float], threshold: float) -> bool:\n    \n\n    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                distance = abs(elem - elem2)\n                if distance < threshold:\n                    return True\n\n    return False\n']
Generated code:  from typing import List


def has_close_elements(numbers: List[float], threshold: float) -> bool:
    numbers.sort()
    for i in range(len(numbers) - 1):
        if abs(numbers[i] - numbers[i + 1]) < threshold:
            return True
    return False
Generated code:  from typing import List


def has_close_elements(numbers: List[float], threshold: float) -> bool:
    for idx, elem in enumerate(numbers):
        for idx2, elem2 in enumerate(numbers):
            if idx!= idx2:
                distance = abs(elem - elem2)
                if distance < threshold:
                    return True

    return False
Generated code:  from typing import List


def has_close_elements(numbers: List[float], threshold: float) -> bool:
    """ Check if in given list of numbers, are any two numbers closer to each other than
    given threshold.
    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)
    False
    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)
    True
    """

    for idx, elem in enumerate(numbers):
        for idx2, elem2 in enumerate(numbers):
            if idx!= idx2:
                distance = abs(elem - elem2)
                if distance < threshold:
                    return True

    return False
Retrieved Documents:  ["from typing import List\n\n\ndef func_0(paren_string: str) -> List[str]:\n    \n\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n"]
Generated code:  from typing import List

def separate_paren_groups(paren_string: str) -> List[str]:
    result = []
    current_string = []
    depth = 0

    for c in paren_string.replace(" ", ""):
        if c == '(':
            depth += 1
            current_string.append(c)
        elif c == ')':
            depth -= 1
            current_string.append(c)

            if depth == 0:
                result.append(''.join(current_string))
                current_string.clear()

    return result
Generated code:  from typing import List


def separate_paren_groups(paren_string: str) -> List[str]:
    result = []
    current_string = []
    current_depth = 0

    for c in paren_string.replace(' ', ''):
        if c == '(':
            current_depth += 1
            current_string.append(c)
        elif c == ')':
            current_depth -= 1
            current_string.append(c)

            if current_depth == 0:
                result.append(''.join(current_string))
                current_string.clear()

    return result
Generated code:  from typing import List


def separate_paren_groups(paren_string: str) -> List[str]:
    result = []
    current_string = []
    current_depth = 0

    for c in paren_string:
        if c =='':
            continue
        if c == '(':
            current_depth += 1
            current_string.append(c)
        elif c == ')':
            current_depth -= 1
            current_string.append(c)

            if current_depth == 0:
                result.append(''.join(current_string))
                current_string.clear()

    return result
Retrieved Documents:  ['\n\ndef func_0(number: float) -> float:\n    \n\n    return number % 1.0\n']
Generated code:  def truncate_number(number: float) -> float:
    return number - int(number)
Generated code:  def truncate_number(number: float) -> float:
    return number - int(number)
Generated code:  def truncate_number(number: float) -> float:
    """ Given a positive floating point number, it can be decomposed into
    and integer part (largest integer smaller than given number) and decimals
    (leftover part always smaller than 1).

    Return the decimal part of the number.
    >>> truncate_number(3.5)
    0.5
    """
    return number - int(number)
Retrieved Documents:  ['from typing import List\n\n\ndef func_0(operations: List[int]) -> bool:\n    \n\n    balance = 0\n\n    for op in operations:\n        balance += op\n        if balance < 0:\n            return True\n\n    return False\n']
Generated code:  from typing import List


def below_zero(operations: List[int]) -> bool:
    balance = 0

    for op in operations:
        balance += op
        if balance < 0:
            return True

    return False
Generated code:  from typing import List


def below_zero(operations: List[int]) -> bool:
    """ You're given a list of deposit and withdrawal operations on a bank account that starts with
    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and
    at that point function should return True. Otherwise it should return False.
    >>> below_zero([1, 2, 3])
    False
    >>> below_zero([1, 2, -4, 5])
    True
    """

    balance = 0

    for op in operations:
        balance += op
        if balance < 0:
            return True

    return False
Generated code:  from typing import List


def below_zero(operations: List[int]) -> bool:
    """ You're given a list of deposit and withdrawal operations on a bank account that starts with
    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and
    at that point function should return True. Otherwise it should return False.
    >>> below_zero([1, 2, 3])
    False
    >>> below_zero([1, 2, -4, 5])
    True
    """

    balance = 0

    for op in operations:
        balance += op
        if balance < 0:
            return True

    return False
Retrieved Documents:  ['def func_0(data):\r\n    n = len(data)\r\n    if n <= 1:\r\n        return 0.0\r\n    mean, sd = avg_calc(data), 0.0\r\n    for el in data:\r\n        sd += (float(el) - mean)**2\r\n    sd = math.sqrt(sd / float(n-1))\r\n    return sd\r\ndef func_1(ls):\r\n    n, mean = len(ls), 0.0\r\n    if n <= 1:\r\n        return ls[0]\r\n    for el in ls:\r\n        mean = mean + float(el)\r\n    mean = mean / float(n)\r\n    return mean']
Generated code:  def mean_absolute_deviation(numbers: List[float]) -> float:
    """ For a given list of input numbers, calculate Mean Absolute Deviation
    around the mean of this dataset.
    Mean Absolute Deviation is the average absolute difference between each
    element and a centerpoint (mean in this case):
    MAD = average | x - x_mean |
    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])
    1.0
    """
    if not numbers:
        return 0.0
    mean = sum(numbers) / len(numbers)
    return sum(abs(x - mean) for x in numbers) / len(numbers)
Generated code:  from typing import List


def mean_absolute_deviation(numbers: List[float]) -> float:
    """ For a given list of input numbers, calculate Mean Absolute Deviation
    around the mean of this dataset.
    Mean Absolute Deviation is the average absolute difference between each
    element and a centerpoint (mean in this case):
    MAD = average | x - x_mean |
    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])
    1.0
    """
    if not numbers:
        return 0.0
    mean = sum(numbers) / len(numbers)
    return sum(abs(x - mean) for x in numbers) / len(numbers)
Generated code:  def mean_absolute_deviation(numbers: List[float]) -> float:
    """ For a given list of input numbers, calculate Mean Absolute Deviation
    around the mean of this dataset.
    Mean Absolute Deviation is the average absolute difference between each
    element and a centerpoint (mean in this case):
    MAD = average | x - x_mean |
    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])
    1.0
    """
    mean = sum(numbers) / len(numbers)
    return sum(abs(x - mean) for x in numbers) / len(numbers)
Retrieved Documents:  ['from typing import List\n\n\ndef func_0(numbers: List[int], delimeter: int) -> List[int]:\n    \n\n    if not numbers:\n        return []\n\n    result = []\n\n    for n in numbers[:-1]:\n        result.append(n)\n        result.append(delimeter)\n\n    result.append(numbers[-1])\n\n    return result\n']
Generated code:  from typing import List


def intersperse(numbers: List[int], delimeter: int) -> List[int]:
    """ Insert a number 'delimeter' between every two consecutive elements of input list `numbers'
    >>> intersperse([], 4)
    []
    >>> intersperse([1, 2, 3], 4)
    [1, 4, 2, 4, 3]
    """

    if not numbers:
        return []

    result = []

    for n in numbers[:-1]:
        result.append(n)
        result.append(delimeter)

    result.append(numbers[-1])

    return result
Generated code:  from typing import List


def intersperse(numbers: List[int], delimeter: int) -> List[int]:
    if not numbers:
        return []

    result = []

    for n in numbers[:-1]:
        result.append(n)
        result.append(delimeter)

    result.append(numbers[-1])

    return result
Generated code:  def intersperse(numbers: List[int], delimeter: int) -> List[int]:
    if not numbers:
        return []

    result = []

    for n in numbers[:-1]:
        result.append(n)
        result.append(delimeter)

    result.append(numbers[-1])

    return result
Retrieved Documents:  ["from typing import List\n\n\ndef func_0(paren_string: str) -> List[int]:\n    \n\n    def func_1(s):\n        depth = 0\n        max_depth = 0\n        for c in s:\n            if c == '(':\n                depth += 1\n                max_depth = max(depth, max_depth)\n            else:\n                depth -= 1\n\n        return max_depth\n\n    return [parse_paren_group(x) for x in paren_string.split(' ') if x]\n"]
Generated code:  from typing import List

def parse_nested_parens(paren_string: str) -> List[int]:
    """ Input to this function is a string represented multiple groups for nested parentheses separated by spaces.
    For each of the group, output the deepest level of nesting of parentheses.
    E.g. (()()) has maximum two levels of nesting while ((())) has three.

    >>> parse_nested_parens('(()()) ((())) () ((())()())')
    [2, 3, 1, 3]
    """
    return [max(map(lambda x: x.count('('), group.split(')'))) for group in paren_string.split(' ') if group]
Generated code:  from typing import List

def parse_nested_parens(paren_string: str) -> List[int]:
    """ Input to this function is a string represented multiple groups for nested parentheses separated by spaces.
    For each of the group, output the deepest level of nesting of parentheses.
    E.g. (()()) has maximum two levels of nesting while ((())) has three.

    >>> parse_nested_parens('(()()) ((())) () ((())()())')
    [2, 3, 1, 3]
    """

    def parse_paren_group(paren_group: str) -> int:
        depth = 0
        max_depth = 0
        for c in paren_group:
            if c == '(':
                depth += 1
                max_depth = max(depth, max_depth)
            elif c == ')':
                depth -= 1
        return max_depth

    return [parse_paren_group(paren_group) for paren_group in paren_string.split(' ') if paren_group]
Generated code:  from typing import List


def parse_nested_parens(paren_string: str) -> List[int]:
    """ Input to this function is a string represented multiple groups for nested parentheses separated by spaces.
    For each of the group, output the deepest level of nesting of parentheses.
    E.g. (()()) has maximum two levels of nesting while ((())) has three.

    >>> parse_nested_parens('(()()) ((())) () ((())()())')
    [2, 3, 1, 3]
    """

    def parse_paren_group(paren_string: str) -> int:
        depth = 0
        max_depth = 0
        for c in paren_string:
            if c == '(':
                depth += 1
                max_depth = max(depth, max_depth)
            else:
                depth -= 1

        return max_depth

    return [parse_paren_group(x) for x in paren_string.split(' ') if x]
Retrieved Documents:  ['from typing import List\n\n\ndef func_0(strings: List[str], substring: str) -> List[str]:\n    \n\n    return [x for x in strings if substring in x]\n']
Generated code:  from typing import List

def filter_by_substring(strings: List[str], substring: str) -> List[str]:
    return [x for x in strings if substring in x]
Generated code:  from typing import List


def filter_by_substring(strings: List[str], substring: str) -> List[str]:
    return [x for x in strings if substring in x]
Generated code:  from typing import List


def filter_by_substring(strings: List[str], substring: str) -> List[str]:
    """ Filter an input list of strings only for ones that contain given substring
    >>> filter_by_substring([], 'a')
    []
    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')
    ['abc', 'bacd', 'array']
    """

    return [x for x in strings if substring in x]
Retrieved Documents:  ['from typing import List, Tuple\n\n\ndef func_0(numbers: List[int]) -> Tuple[int, int]:\n    \n\n    sum_value = 0\n    prod_value = 1\n\n    for n in numbers:\n        sum_value += n\n        prod_value *= n\n    return sum_value, prod_value\n']
Generated code:  from typing import List, Tuple

def sum_product(numbers: List[int]) -> Tuple[int, int]:
    sum_value = 0
    prod_value = 1

    for n in numbers:
        sum_value += n
        prod_value *= n
    return sum_value, prod_value
Generated code:  from typing import List, Tuple


def sum_product(numbers: List[int]) -> Tuple[int, int]:
    """ For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.
    Empty sum should be equal to 0 and empty product should be equal to 1.
    >>> sum_product([])
    (0, 1)
    >>> sum_product([1, 2, 3, 4])
    (10, 24)
    """
    sum_value = 0
    prod_value = 1

    for n in numbers:
        sum_value += n
        prod_value *= n
    return sum_value, prod_value
Generated code:  from typing import List, Tuple


def sum_product(numbers: List[int]) -> Tuple[int, int]:
    """ For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.
    Empty sum should be equal to 0 and empty product should be equal to 1.
    >>> sum_product([])
    (0, 1)
    >>> sum_product([1, 2, 3, 4])
    (10, 24)
    """

    sum_value = 0
    prod_value = 1

    for n in numbers:
        sum_value += n
        prod_value *= n
    return sum_value, prod_value
Retrieved Documents:  ['from typing import List, Tuple\n\n\ndef func_0(numbers: List[int]) -> List[int]:\n    \n\n    running_max = None\n    result = []\n\n    for n in numbers:\n        if running_max is None:\n            running_max = n\n        else:\n            running_max = max(running_max, n)\n\n        result.append(running_max)\n\n    return result\n']
Generated code:  from typing import List, Tuple


def rolling_max(numbers: List[int]) -> List[int]:
    """ From a given list of integers, generate a list of rolling maximum element found until given moment
    in the sequence.
    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])
    [1, 2, 3, 3, 3, 4, 4]
    """

    running_max = None
    result = []

    for n in numbers:
        if running_max is None:
            running_max = n
        else:
            running_max = max(running_max, n)

        result.append(running_max)

    return result
Generated code:  from typing import List


def rolling_max(numbers: List[int]) -> List[int]:
    """ From a given list of integers, generate a list of rolling maximum element found until given moment
    in the sequence.
    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])
    [1, 2, 3, 3, 3, 4, 4]
    """

    running_max = None
    result = []

    for n in numbers:
        if running_max is None:
            running_max = n
        else:
            running_max = max(running_max, n)

        result.append(running_max)

    return result
Generated code:  from typing import List, Tuple


def rolling_max(numbers: List[int]) -> List[int]:
    """ From a given list of integers, generate a list of rolling maximum element found until given moment
    in the sequence.
    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])
    [1, 2, 3, 3, 3, 4, 4]
    """

    running_max = None
    result = []

    for n in numbers:
        if running_max is None:
            running_max = n
        else:
            running_max = max(running_max, n)

        result.append(running_max)

    return result
Retrieved Documents:  ["\n\ndef func_0(string: str) -> bool:\n    \n    return string == string[::-1]\n\n\ndef func_1(string: str) -> str:\n    \n\n    if not string:\n        return ''\n\n    beginning_of_suffix = 0\n\n    while not is_palindrome(string[beginning_of_suffix:]):\n        beginning_of_suffix += 1\n\n    return string + string[:beginning_of_suffix][::-1]\n"]
Generated code:  def make_palindrome(string: str) -> str:
    """ Find the shortest palindrome that begins with a supplied string.
    Algorithm idea is simple:
    - Find the longest postfix of supplied string that is a palindrome.
    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.
    >>> make_palindrome('')
    ''
    >>> make_palindrome('cat')
    'catac'
    >>> make_palindrome('cata')
    'catac'
    """

    if not string:
        return ''

    beginning_of_suffix = 0

    while not is_palindrome(string[beginning_of_suffix:]):
        beginning_of_suffix += 1

    return string + string[:beginning_of_suffix][::-1]
Generated code:  def make_palindrome(string: str) -> str:
    if not string:
        return ''

    beginning_of_suffix = 0

    while not is_palindrome(string[beginning_of_suffix:]):
        beginning_of_suffix += 1

    return string + string[:beginning_of_suffix][::-1]
Generated code:  def make_palindrome(string: str) -> str:
    """ Find the shortest palindrome that begins with a supplied string.
    Algorithm idea is simple:
    - Find the longest postfix of supplied string that is a palindrome.
    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.
    >>> make_palindrome('')
    ''
    >>> make_palindrome('cat')
    'catac'
    >>> make_palindrome('cata')
    'catac'
    """

    if not string:
        return ''

    beginning_of_suffix = 0

    while not is_palindrome(string[beginning_of_suffix:]):
        beginning_of_suffix += 1

    return string + string[:beginning_of_suffix][::-1]
Retrieved Documents:  ["from typing import List\n\n\ndef func_0(a: str, b: str) -> str:\n    \n\n    def func_1(i, j):\n        if i == j:\n            return '0'\n        else:\n            return '1'\n\n    return ''.join(xor(x, y) for x, y in zip(a, b))\n"]
Generated code:  from typing import List

def string_xor(a: str, b: str) -> str:
    return ''.join(str(int(x) ^ int(y)) for x, y in zip(a, b))
Generated code:  from typing import List


def string_xor(a: str, b: str) -> str:
    """ Input are two strings a and b consisting only of 1s and 0s.
    Perform binary XOR on these inputs and return result also as a string.
    >>> string_xor('010', '110')
    '100'
    """
    return ''.join(str(int(x) ^ int(y)) for x, y in zip(a, b))
Generated code:  def string_xor(a: str, b: str) -> str:
    return ''.join(str(int(x) ^ int(y)) for x, y in zip(a, b))
Retrieved Documents:  ['from typing import List, Optional\n\n\ndef func_0(strings: List[str]) -> Optional[str]:\n    \n\n    if not strings:\n        return None\n\n    maxlen = max(len(x) for x in strings)\n    for s in strings:\n        if len(s) == maxlen:\n            return s\n']
Generated code:  from typing import List, Optional


def longest(strings: List[str]) -> Optional[str]:
    """ Out of list of strings, return the longest one. Return the first one in case of multiple
    strings of the same length. Return None in case the input list is empty.
    >>> longest([])
    
    >>> longest(['a', 'b', 'c'])
    'a'
    >>> longest(['a', 'bb', 'ccc'])
    'ccc'
    """

    if not strings:
        return None

    maxlen = max(len(x) for x in strings)
    for s in strings:
        if len(s) == maxlen:
            return s
Generated code:  from typing import List, Optional


def longest(strings: List[str]) -> Optional[str]:
    """ Out of list of strings, return the longest one. Return the first one in case of multiple
    strings of the same length. Return None in case the input list is empty.
    >>> longest([])

    >>> longest(['a', 'b', 'c'])
    'a'
    >>> longest(['a', 'bb', 'ccc'])
    'ccc'
    """

    if not strings:
        return None

    maxlen = max(len(x) for x in strings)
    for s in strings:
        if len(s) == maxlen:
            return s
Generated code:  from typing import List, Optional


def longest(strings: List[str]) -> Optional[str]:
    """ Out of list of strings, return the longest one. Return the first one in case of multiple
    strings of the same length. Return None in case the input list is empty.
    >>> longest([])

    >>> longest(['a', 'b', 'c'])
    'a'
    >>> longest(['a', 'bb', 'ccc'])
    'ccc'
    """

    if not strings:
        return None

    maxlen = max(len(x) for x in strings)
    for s in strings:
        if len(s) == maxlen:
            return s
Retrieved Documents:  ['def func_0(A,B):  \r\n    if (A > B): \r\n        swap(A,B)  \r\n    B = B // math.gcd(A,B);  \r\n    return B - 1']
Generated code:  import math

def greatest_common_divisor(a: int, b: int) -> int:
    return math.gcd(a, b)
Generated code:  def greatest_common_divisor(a: int, b: int) -> int:
    while b:
        a, b = b, a % b
    return a
Generated code:  import math

def greatest_common_divisor(a: int, b: int) -> int:
    """ Return a greatest common divisor of two integers a and b
    >>> greatest_common_divisor(3, 5)
    1
    >>> greatest_common_divisor(25, 15)
    5
    """
    return math.gcd(a, b)
Retrieved Documents:  ['from typing import List\n\n\ndef func_0(strings: List[str], prefix: str) -> List[str]:\n    \n\n    return [x for x in strings if x.startswith(prefix)]\n']
Generated code:  from typing import List


def all_prefixes(string: str) -> List[str]:
    """ Return list of all prefixes from shortest to longest of the input string
    >>> all_prefixes('abc')
    ['a', 'ab', 'abc']
    """
    return [string[:i] for i in range(1, len(string) + 1)]
Generated code:  from typing import List


def all_prefixes(string: str) -> List[str]:
    """ Return list of all prefixes from shortest to longest of the input string
    >>> all_prefixes('abc')
    ['a', 'ab', 'abc']
    """
    return [string[:i+1] for i in range(len(string))]
Generated code:  from typing import List


def all_prefixes(string: str) -> List[str]:
    """ Return list of all prefixes from shortest to longest of the input string
    >>> all_prefixes('abc')
    ['a', 'ab', 'abc']
    """
    return [string[:i+1] for i in range(len(string))]
Retrieved Documents:  ["\n\ndef func_0(n: int) -> str:\n    \n\n    return ' '.join([str(x) for x in range(n + 1)])\n"]
Generated code:  def string_sequence(n: int) -> str:
    return''.join([str(x) for x in range(n + 1)])
Generated code:  def string_sequence(n: int) -> str:
    """ Return a string containing space-delimited numbers starting from 0 upto n inclusive.
    >>> string_sequence(0)
    '0'
    >>> string_sequence(5)
    '0 1 2 3 4 5'
    """
    return''.join([str(x) for x in range(n + 1)])
Generated code:  def string_sequence(n: int) -> str:
    """ Return a string containing space-delimited numbers starting from 0 upto n inclusive.
    >>> string_sequence(0)
    '0'
    >>> string_sequence(5)
    '0 1 2 3 4 5'
    """
    return''.join([str(x) for x in range(n + 1)])
Retrieved Documents:  ['def func_0(string,char):\r\n count = 0\r\n for i in range(len(string)):\r\n    if(string[i] == char):\r\n        count = count + 1\r\n return count']
Generated code:  def count_distinct_characters(string: str) -> int:
    """ Given a string, find out how many distinct characters (regardless of case) does it consist of
    >>> count_distinct_characters('xyzXYZ')
    3
    >>> count_distinct_characters('Jerry')
    4
    """
    return len(set(string.lower()))
Generated code:  def count_distinct_characters(string: str) -> int:
    return len(set(string.lower()))
Generated code:  def count_distinct_characters(string: str) -> int:
    return len(set(string.lower()))
Retrieved Documents:  ["from typing import List\n\n\ndef func_0(music_string: str) -> List[int]:\n    \n\n    note_map = {'o': 4, 'o|': 2, '.|': 1}\n    return [note_map[x] for x in music_string.split(' ') if x]\n"]
Generated code:  from typing import List


def parse_music(music_string: str) -> List[int]:
    """ Input to this function is a string representing musical notes in a special ASCII format.
    Your task is to parse this string and return list of integers corresponding to how many beats does each
    not last.

    Here is a legend:
    'o' - whole note, lasts four beats
    'o|' - half note, lasts two beats
    '.|' - quater note, lasts one beat

    >>> parse_music('o o|.| o| o|.|.|.|.| o o')
    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]
    """

    note_map = {'o': 4, 'o|': 2, '.|': 1}
    return [note_map[x] for x in music_string.split(' ') if x]
Generated code:  from typing import List


def parse_music(music_string: str) -> List[int]:
    """ Input to this function is a string representing musical notes in a special ASCII format.
    Your task is to parse this string and return list of integers corresponding to how many beats does each
    not last.

    Here is a legend:
    'o' - whole note, lasts four beats
    'o|' - half note, lasts two beats
    '.|' - quater note, lasts one beat

    >>> parse_music('o o|.| o| o|.|.|.|.| o o')
    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]
    """

    note_map = {'o': 4, 'o|': 2, '.|': 1}
    return [note_map[x] for x in music_string.split(' ') if x]
Generated code:  from typing import List


def parse_music(music_string: str) -> List[int]:
    """ Input to this function is a string representing musical notes in a special ASCII format.
    Your task is to parse this string and return list of integers corresponding to how many beats does each
    not last.

    Here is a legend:
    'o' - whole note, lasts four beats
    'o|' - half note, lasts two beats
    '.|' - quater note, lasts one beat

    >>> parse_music('o o|.| o| o|.|.|.|.| o o')
    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]
    """

    note_map = {'o': 4, 'o|': 2, '.|': 1}
    return [note_map[x] for x in music_string.split(' ') if x]
Retrieved Documents:  ['\n\ndef func_0(string: str, substring: str) -> int:\n    \n\n    times = 0\n\n    for i in range(len(string) - len(substring) + 1):\n        if string[i:i+len(substring)] == substring:\n            times += 1\n\n    return times\n']
Generated code:  def how_many_times(string: str, substring: str) -> int:
    times = 0

    for i in range(len(string) - len(substring) + 1):
        if string[i:i+len(substring)] == substring:
            times += 1

    return times
Generated code:  def how_many_times(string: str, substring: str) -> int:
    """ Find how many times a given substring can be found in the original string. Count overlaping cases.
    >>> how_many_times('', 'a')
    0
    >>> how_many_times('aaa', 'a')
    3
    >>> how_many_times('aaaa', 'aa')
    3
    """

    times = 0

    for i in range(len(string) - len(substring) + 1):
        if string[i:i+len(substring)] == substring:
            times += 1

    return times
Generated code:  def how_many_times(string: str, substring: str) -> int:
    """ Find how many times a given substring can be found in the original string. Count overlaping cases.
    >>> how_many_times('', 'a')
    0
    >>> how_many_times('aaa', 'a')
    3
    >>> how_many_times('aaaa', 'aa')
    3
    """

    times = 0

    for i in range(len(string) - len(substring) + 1):
        if string[i:i+len(substring)] == substring:
            times += 1

    return times
Retrieved Documents:  ["from typing import List\n\n\ndef func_0(numbers: str) -> str:\n    \n\n    value_map = {\n        'zero': 0,\n        'one': 1,\n        'two': 2,\n        'three': 3,\n        'four': 4,\n        'five': 5,\n        'six': 6,\n        'seven': 7,\n        'eight': 8,\n        'nine': 9\n    }\n    return ' '.join(sorted([x for x in numbers.split(' ') if x], key=lambda x: value_map[x]))\n"]
Generated code:  from typing import List


def sort_numbers(numbers: str) -> str:
    """ Input is a space-delimited string of numberals from 'zero' to 'nine'.
    Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five','six','seven', 'eight' and 'nine'.
    Return the string with numbers sorted from smallest to largest
    >>> sort_numbers('three one five')
    'one three five'
    """

    value_map = {
        'zero': 0,
        'one': 1,
        'two': 2,
        'three': 3,
        'four': 4,
        'five': 5,
       'six': 6,
       'seven': 7,
        'eight': 8,
        'nine': 9
    }
    return''.join(sorted([x for x in numbers.split(' ') if x], key=lambda x: value_map[x]))
Generated code:  from typing import List


def sort_numbers(numbers: str) -> str:
    """ Input is a space-delimited string of numberals from 'zero' to 'nine'.
    Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five','six','seven', 'eight' and 'nine'.
    Return the string with numbers sorted from smallest to largest
    >>> sort_numbers('three one five')
    'one three five'
    """

    value_map = {
        'zero': 0,
        'one': 1,
        'two': 2,
        'three': 3,
        'four': 4,
        'five': 5,
       'six': 6,
       'seven': 7,
        'eight': 8,
        'nine': 9
    }
    return''.join(sorted([x for x in numbers.split(' ') if x], key=lambda x: value_map[x]))
Generated code:  from typing import List


def sort_numbers(numbers: str) -> str:
    """ Input is a space-delimited string of numberals from 'zero' to 'nine'.
    Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five','six','seven', 'eight' and 'nine'.
    Return the string with numbers sorted from smallest to largest
    >>> sort_numbers('three one five')
    'one three five'
    """

    value_map = {
        'zero': 0,
        'one': 1,
        'two': 2,
        'three': 3,
        'four': 4,
        'five': 5,
       'six': 6,
       'seven': 7,
        'eight': 8,
        'nine': 9
    }
    return''.join(sorted([x for x in numbers.split(' ') if x], key=lambda x: value_map[x]))
Retrieved Documents:  ['from typing import List, Tuple\n\n\ndef func_0(numbers: List[float]) -> Tuple[float, float]:\n    \n\n    closest_pair = None\n    distance = None\n\n    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                if distance is None:\n                    distance = abs(elem - elem2)\n                    closest_pair = tuple(sorted([elem, elem2]))\n                else:\n                    new_distance = abs(elem - elem2)\n                    if new_distance < distance:\n                        distance = new_distance\n                        closest_pair = tuple(sorted([elem, elem2]))\n\n    return closest_pair\n']
Generated code:  from typing import List, Tuple


def find_closest_elements(numbers: List[float]) -> Tuple[float, float]:
    closest_pair = None
    distance = None

    for idx, elem in enumerate(numbers):
        for idx2, elem2 in enumerate(numbers):
            if idx!= idx2:
                if distance is None:
                    distance = abs(elem - elem2)
                    closest_pair = tuple(sorted([elem, elem2]))
                else:
                    new_distance = abs(elem - elem2)
                    if new_distance < distance:
                        distance = new_distance
                        closest_pair = tuple(sorted([elem, elem2]))

    return closest_pair
Generated code:  from typing import List, Tuple


def find_closest_elements(numbers: List[float]) -> Tuple[float, float]:
    """ From a supplied list of numbers (of length at least two) select and return two that are the closest to each
    other and return them in order (smaller number, larger number).
    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])
    (2.0, 2.2)
    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])
    (2.0, 2.0)
    """

    closest_pair = None
    smallest_distance = None

    for i in range(len(numbers)):
        for j in range(i + 1, len(numbers)):
            distance = abs(numbers[i] - numbers[j])
            if smallest_distance is None or distance < smallest_distance:
                smallest_distance = distance
                closest_pair = (min(numbers[i], numbers[j]), max(numbers[i], numbers[j]))

    return closest_pair
Generated code:  from typing import List, Tuple


def find_closest_elements(numbers: List[float]) -> Tuple[float, float]:
    """ From a supplied list of numbers (of length at least two) select and return two that are the closest to each
    other and return them in order (smaller number, larger number).
    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])
    (2.0, 2.2)
    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])
    (2.0, 2.0)
    """

    closest_pair = None
    distance = None

    for idx, elem in enumerate(numbers):
        for idx2, elem2 in enumerate(numbers):
            if idx!= idx2:
                if distance is None:
                    distance = abs(elem - elem2)
                    closest_pair = tuple(sorted([elem, elem2]))
                else:
                    new_distance = abs(elem - elem2)
                    if new_distance < distance:
                        distance = new_distance
                        closest_pair = tuple(sorted([elem, elem2]))

    return closest_pair
Retrieved Documents:  ['from typing import List\n\n\ndef func_0(numbers: List[float]) -> List[float]:\n    \n\n    min_number = min(numbers)\n    max_number = max(numbers)\n    return [(x - min_number) / (max_number - min_number) for x in numbers]\n']
Generated code:  from typing import List


def rescale_to_unit(numbers: List[float]) -> List[float]:
    """ Given list of numbers (of at least two elements), apply a linear transform to that list,
    such that the smallest number will become 0 and the largest will become 1
    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])
    [0.0, 0.25, 0.5, 0.75, 1.0]
    """
    min_number = min(numbers)
    max_number = max(numbers)
    return [(x - min_number) / (max_number - min_number) for x in numbers]
Generated code:  from typing import List


def rescale_to_unit(numbers: List[float]) -> List[float]:
    """ Given list of numbers (of at least two elements), apply a linear transform to that list,
    such that the smallest number will become 0 and the largest will become 1
    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])
    [0.0, 0.25, 0.5, 0.75, 1.0]
    """

    min_number = min(numbers)
    max_number = max(numbers)
    return [(x - min_number) / (max_number - min_number) for x in numbers]
Generated code:  from typing import List


def rescale_to_unit(numbers: List[float]) -> List[float]:
    """ Given list of numbers (of at least two elements), apply a linear transform to that list,
    such that the smallest number will become 0 and the largest will become 1
    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])
    [0.0, 0.25, 0.5, 0.75, 1.0]
    """

    min_number = min(numbers)
    max_number = max(numbers)
    return [(x - min_number) / (max_number - min_number) for x in numbers]
Retrieved Documents:  ['from typing import List, Any\n\n\ndef func_0(values: List[Any]) -> List[int]:\n    \n\n    return [x for x in values if isinstance(x, int)]\n']
Generated code:  from typing import List, Any


def filter_integers(values: List[Any]) -> List[int]:
    """ Filter given list of any python values only for integers
    >>> filter_integers(['a', 3.14, 5])
    [5]
    >>> filter_integers([1, 2, 3, 'abc', {}, []])
    [1, 2, 3]
    """

    return [x for x in values if isinstance(x, int)]
Generated code:  from typing import List, Any


def filter_integers(values: List[Any]) -> List[int]:
    return [x for x in values if isinstance(x, int)]
Generated code:  from typing import List, Any


def filter_integers(values: List[Any]) -> List[int]:
    """ Filter given list of any python values only for integers
    >>> filter_integers(['a', 3.14, 5])
    [5]
    >>> filter_integers([1, 2, 3, 'abc', {}, []])
    [1, 2, 3]
    """

    return [x for x in values if isinstance(x, int)]
Retrieved Documents:  ['\n\ndef func_0(string: str) -> int:\n    \n\n    return len(string)\n']
Generated code:  def strlen(string: str) -> int:
    return len(string)
Generated code:  def strlen(string: str) -> int:
    """ Return length of given string
    >>> strlen('')
    0
    >>> strlen('abc')
    3
    """
    return len(string)
Generated code:  def strlen(string: str) -> int:
    return len(string)
Retrieved Documents:  ['\n\ndef func_0(n: int):\n    \n\n    def func_1(k):\n        if k < 2:\n            return False\n        for i in range(2, k - 1):\n            if k % i == 0:\n                return False\n        return True\n    largest = 1\n    for j in range(2, n + 1):\n        if n % j == 0 and is_prime(j):\n            largest = max(largest, j)\n    return largest\n']
Generated code:  def largest_divisor(n: int) -> int:
    """ For a given number n, find the largest number that divides n evenly, smaller than n
    >>> largest_divisor(15)
    5
    """
    for i in range(n-1, 0, -1):
        if n % i == 0:
            return i
    return 1
Generated code:  def largest_divisor(n: int) -> int:
    """ For a given number n, find the largest number that divides n evenly, smaller than n
    >>> largest_divisor(15)
    5
    """
    for i in range(n-1, 1, -1):
        if n % i == 0:
            return i
    return 1
Generated code:  def largest_divisor(n: int) -> int:
    """ For a given number n, find the largest number that divides n evenly, smaller than n
    >>> largest_divisor(15)
    5
    """
    for i in range(n-1, 1, -1):
        if n % i == 0:
            return i
    return 1
Retrieved Documents:  ['\ndef func_0(n):\n    \n\n    primes = []\n    for i in range(2, n):\n        is_prime = True\n        for j in range(2, i):\n            if i % j == 0:\n                is_prime = False\n                break\n        if is_prime:\n            primes.append(i)\n    return primes\n\n']
Generated code:  def factorize(n: int) -> List[int]:
    factors = []
    divisor = 2
    while divisor * divisor <= n:
        while n % divisor == 0:
            factors.append(divisor)
            n //= divisor
        divisor += 1
    if n > 1:
        factors.append(n)
    return factors
Generated code:  def factorize(n: int) -> List[int]:
    factors = []
    divisor = 2
    while divisor * divisor <= n:
        while n % divisor == 0:
            factors.append(divisor)
            n //= divisor
        divisor += 1
    if n > 1:
        factors.append(n)
    return factors
Generated code:  def factorize(n: int) -> List[int]:
    """ Return list of prime factors of given integer in the order from smallest to largest.
    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.
    Input number should be equal to the product of all factors
    >>> factorize(8)
    [2, 2, 2]
    >>> factorize(25)
    [5, 5]
    >>> factorize(70)
    [2, 5, 7]
    """
    factors = []
    divisor = 2
    while divisor * divisor <= n:
        while n % divisor == 0:
            factors.append(divisor)
            n //= divisor
        divisor += 1
    if n > 1:
        factors.append(n)
    return factors
Retrieved Documents:  ['from typing import List\n\n\ndef func_0(numbers: List[int]) -> List[int]:\n    \n\n    import collections\n    c = collections.Counter(numbers)\n    return [n for n in numbers if c[n] <= 1]\n']
Generated code:  from typing import List


def remove_duplicates(numbers: List[int]) -> List[int]:
    """ From a list of integers, remove all elements that occur more than once.
    Keep order of elements left the same as in the input.
    >>> remove_duplicates([1, 2, 3, 2, 4])
    [1, 3, 4]
    """
    seen = set()
    result = []
    for num in numbers:
        if num not in seen:
            seen.add(num)
            result.append(num)
    return result
Generated code:  from typing import List


def remove_duplicates(numbers: List[int]) -> List[int]:
    """ From a list of integers, remove all elements that occur more than once.
    Keep order of elements left the same as in the input.
    >>> remove_duplicates([1, 2, 3, 2, 4])
    [1, 3, 4]
    """
    seen = set()
    result = []
    for num in numbers:
        if num not in seen:
            seen.add(num)
            result.append(num)
    return result
Generated code:  from typing import List


def remove_duplicates(numbers: List[int]) -> List[int]:
    """ From a list of integers, remove all elements that occur more than once.
    Keep order of elements left the same as in the input.
    >>> remove_duplicates([1, 2, 3, 2, 4])
    [1, 3, 4]
    """
    seen = set()
    seen_add = seen.add
    seen_twice = set()
    seen_twice_add = seen_twice.add
    for x in numbers:
        if x in seen:
            seen_twice_add(x)
        else:
            seen_add(x)
    return [x for x in numbers if x not in seen_twice]
Retrieved Documents:  ['\n\ndef func_0(string: str) -> str:\n    \n\n    return string.swapcase()\n']
Generated code:  def flip_case(string: str) -> str:
    return string.swapcase()
Generated code:  def flip_case(string: str) -> str:
    return string.swapcase()
Generated code:  def flip_case(string: str) -> str:
    return string.swapcase()
Retrieved Documents:  ["from typing import List\n\n\ndef func_0(strings: List[str]) -> str:\n    \n\n    return ''.join(strings)\n"]
Generated code:  from typing import List

def concatenate(strings: List[str]) -> str:
    """ Concatenate list of strings into a single string
    >>> concatenate([])
    ''
    >>> concatenate(['a', 'b', 'c'])
    'abc'
    """
    return ''.join(strings)
Generated code:  from typing import List


def concatenate(strings: List[str]) -> str:
    """ Concatenate list of strings into a single string
    >>> concatenate([])
    ''
    >>> concatenate(['a', 'b', 'c'])
    'abc'
    """
    return ''.join(strings)
Generated code:  from typing import List


def concatenate(strings: List[str]) -> str:
    """ Concatenate list of strings into a single string
    >>> concatenate([])
    ''
    >>> concatenate(['a', 'b', 'c'])
    'abc'
    """
    return ''.join(strings)
Retrieved Documents:  ['from typing import List\n\n\ndef func_0(strings: List[str], prefix: str) -> List[str]:\n    \n\n    return [x for x in strings if x.startswith(prefix)]\n']
Generated code:  from typing import List


def filter_by_prefix(strings: List[str], prefix: str) -> List[str]:
    """ Filter an input list of strings only for ones that start with a given prefix.
    >>> filter_by_prefix([], 'a')
    []
    >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')
    ['abc', 'array']
    """

    return [x for x in strings if x.startswith(prefix)]
Generated code:  from typing import List


def filter_by_prefix(strings: List[str], prefix: str) -> List[str]:
    """ Filter an input list of strings only for ones that start with a given prefix.
    >>> filter_by_prefix([], 'a')
    []
    >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')
    ['abc', 'array']
    """

    return [x for x in strings if x.startswith(prefix)]
Generated code:  from typing import List


def filter_by_prefix(strings: List[str], prefix: str) -> List[str]:
    """ Filter an input list of strings only for ones that start with a given prefix.
    >>> filter_by_prefix([], 'a')
    []
    >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')
    ['abc', 'array']
    """

    return [x for x in strings if x.startswith(prefix)]
Retrieved Documents:  ['\n\ndef func_0(l: list):\n    \n\n    return [e for e in l if e > 0]\n']
Generated code:  def get_positive(l: list):
    return [e for e in l if e > 0]
Generated code:  def get_positive(l: list):
    return [e for e in l if e > 0]
Generated code:  def get_positive(l: list):
    return [e for e in l if e > 0]
Retrieved Documents:  ['\ndef func_0(n):\n    \n\n    primes = []\n    for i in range(2, n):\n        is_prime = True\n        for j in range(2, i):\n            if i % j == 0:\n                is_prime = False\n                break\n        if is_prime:\n            primes.append(i)\n    return primes\n\n']
Generated code:  def is_prime(n):
    if n < 2:
        return False
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False
    return True
Generated code:  def is_prime(n):
    if n < 2:
        return False
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False
    return True
Generated code:  def is_prime(n):
    if n < 2:
        return False
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False
    return True
Retrieved Documents:  ['import math\n\n\ndef func_0(xs: list, x: float):\n    \n    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])\n\n\ndef func_1(xs: list):\n    \n\n    begin, end = -1., 1.\n    while poly(xs, begin) * poly(xs, end) > 0:\n        begin *= 2.0\n        end *= 2.0\n    while end - begin > 1e-10:\n        center = (begin + end) / 2.0\n        if poly(xs, center) * poly(xs, begin) > 0:\n            begin = center\n        else:\n            end = center\n    return begin\n']
Generated code:  import math


def poly(xs: list, x: float):
    """
    Evaluates polynomial with coefficients xs at point x.
    return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n
    """
    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])


def find_zero(xs: list):
    """ xs are coefficients of a polynomial.
    find_zero find x such that poly(x) = 0.
    find_zero returns only only zero point, even if there are many.
    Moreover, find_zero only takes list xs having even number of coefficients
    and largest non zero coefficient as it guarantees
    a solution.
    >>> round(find_zero([1, 2]), 2) # f(x) = 1 + 2x
    -0.5
    >>> round(find_zero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3
    1.0
    """

    begin, end = -1., 1.
    while poly(xs, begin) * poly(xs, end) > 0:
        begin *= 2.0
        end *= 2.0
    while end - begin > 1e-10:
        center = (begin + end) / 2.0
        if poly(xs, center) * poly(xs, begin) > 0:
            begin = center
        else:
            end = center
    return begin
Generated code:  import math

def poly(xs: list, x: float):
    """
    Evaluates polynomial with coefficients xs at point x.
    return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n
    """
    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])

def find_zero(xs: list):
    """ xs are coefficients of a polynomial.
    find_zero find x such that poly(x) = 0.
    find_zero returns only only zero point, even if there are many.
    Moreover, find_zero only takes list xs having even number of coefficients
    and largest non zero coefficient as it guarantees
    a solution.
    >>> round(find_zero([1, 2]), 2) # f(x) = 1 + 2x
    -0.5
    >>> round(find_zero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3
    1.0
    """
    begin, end = -1., 1.
    while poly(xs, begin) * poly(xs, end) > 0:
        begin *= 2.0
        end *= 2.0
    while end - begin > 1e-10:
        center = (begin + end) / 2.0
        if poly(xs, center) * poly(xs, begin) > 0:
            begin = center
        else:
            end = center
    return begin
Generated code:  import math

def poly(xs: list, x: float):
    """
    Evaluates polynomial with coefficients xs at point x.
    return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n
    """
    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])

def find_zero(xs: list):
    """ xs are coefficients of a polynomial.
    find_zero find x such that poly(x) = 0.
    find_zero returns only only zero point, even if there are many.
    Moreover, find_zero only takes list xs having even number of coefficients
    and largest non zero coefficient as it guarantees
    a solution.
    >>> round(find_zero([1, 2]), 2) # f(x) = 1 + 2x
    -0.5
    >>> round(find_zero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3
    1.0
    """
    begin, end = -1., 1.
    while poly(xs, begin) * poly(xs, end) > 0:
        begin *= 2.0
        end *= 2.0
    while end - begin > 1e-10:
        center = (begin + end) / 2.0
        if poly(xs, center) * poly(xs, begin) > 0:
            begin = center
        else:
            end = center
    return begin
Retrieved Documents:  ['\n\ndef func_0(l: list):\n    \n\n    l = list(l)\n    l[::3] = sorted(l[::3])\n    return l\n']
Generated code:  def sort_third(l: list):
    l[::3] = sorted(l[::3])
    return l
Generated code:  def sort_third(l: list):
    """This function takes a list l and returns a list l' such that
    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal
    to the values of the corresponding indicies of l, but sorted.
    >>> sort_third([1, 2, 3])
    [1, 2, 3]
    >>> sort_third([5, 6, 3, 4, 8, 9, 2])
    [2, 6, 3, 4, 8, 9, 5]
    """
    l_copy = l[:]
    l_copy[::3] = sorted(l[::3])
    return l_copy
Generated code:  def sort_third(l: list):
    """This function takes a list l and returns a list l' such that
    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal
    to the values of the corresponding indicies of l, but sorted.
    >>> sort_third([1, 2, 3])
    [1, 2, 3]
    >>> sort_third([5, 6, 3, 4, 8, 9, 2])
    [2, 6, 3, 4, 8, 9, 5]
    """
    l_copy = l.copy()
    l_copy[::3] = sorted(l[::3])
    return l_copy
Retrieved Documents:  ['\n\ndef func_0(l: list):\n    \n\n    return sorted(list(set(l)))\n']
Generated code:  def unique(l: list):
    """Return sorted unique elements in a list
    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])
    [0, 2, 3, 5, 9, 123]
    """
    return sorted(list(set(l)))
Generated code:  def unique(l: list):
    return sorted(list(set(l)))
Generated code:  def unique(l: list):
    """Return sorted unique elements in a list
    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])
    [0, 2, 3, 5, 9, 123]
    """
    return sorted(set(l))
Retrieved Documents:  ['def func_0(lst): \r\n    maxList = max((x) for x in lst) \r\n    return maxList']
Generated code:  def max_element(l: list):
    """Return maximum element in the list.
    >>> max_element([1, 2, 3])
    3
    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])
    123
    """
    return max(l)
Generated code:  def max_element(l: list):
    """Return maximum element in the list.
    >>> max_element([1, 2, 3])
    3
    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])
    123
    """
    return max(l)
Generated code:  def max_element(l: list):
    """Return maximum element in the list.
    >>> max_element([1, 2, 3])
    3
    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])
    123
    """
    return max(l)
Retrieved Documents:  ['def func_0(n): \r\n\treturn int(n * (7 * n - 5) / 2) ']
Generated code:  def fizz_buzz(n: int) -> int:
    count = 0
    for i in range(n):
        if i % 11 == 0 or i % 13 == 0:
            count += str(i).count('7')
    return count
Generated code:  def fizz_buzz(n: int) -> int:
    count = 0
    for i in range(1, n):
        if i % 11 == 0 or i % 13 == 0:
            count += str(i).count('7')
    return count
Generated code:  def fizz_buzz(n: int) -> int:
    count = 0
    for i in range(n):
        if i % 11 == 0 or i % 13 == 0:
            count += str(i).count('7')
    return count
Retrieved Documents:  ['\n\ndef func_0(l: list):\n    \n\n    evens = l[::2]\n    odds = l[1::2]\n    evens.sort()\n    ans = []\n    for e, o in zip(evens, odds):\n        ans.extend([e, o])\n    if len(evens) > len(odds):\n        ans.append(evens[-1])\n    return ans\n']
Generated code:  def sort_even(l: list):
    """This function takes a list l and returns a list l' such that
    l' is identical to l in the odd indicies, while its values at the even indicies are equal
    to the values of the even indicies of l, but sorted.
    >>> sort_even([1, 2, 3])
    [1, 2, 3]
    >>> sort_even([5, 6, 3, 4])
    [3, 6, 5, 4]
    """
    return [l[i] if i % 2 else sorted(l)[i//2] for i in range(len(l))]
Generated code:  def sort_even(l: list):
    """This function takes a list l and returns a list l' such that
    l' is identical to l in the odd indicies, while its values at the even indicies are equal
    to the values of the even indicies of l, but sorted.
    >>> sort_even([1, 2, 3])
    [1, 2, 3]
    >>> sort_even([5, 6, 3, 4])
    [3, 6, 5, 4]
    """
    # Create a copy of the list
    l_prime = l[:]
    # Sort the even-indexed elements
    l_prime[::2] = sorted(l[::2])
    return l_prime
Generated code:  def sort_even(l: list):
    evens = l[::2]
    odds = l[1::2]
    evens.sort()
    ans = []
    for e, o in zip(evens, odds):
        ans.extend([e, o])
    if len(evens) > len(odds):
        ans.append(evens[-1])
    return ans
Retrieved Documents:  ['\n\ndef func_0(s: str):\n    \n    # split string to groups. Each of length 3.\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]\n    # cycle elements in each group. Unless group has fewer elements than 3.\n    groups = [(group[1:] + group[0]) if len(group) == 3 else group for group in groups]\n    return "".join(groups)\n\n\ndef func_1(s: str):\n    \n\n    return encode_cyclic(encode_cyclic(s))\n']
Generated code:  def decode_cyclic(s: str):
    """
    takes as input string encoded with encode_cyclic function. Returns decoded string.
    """
    # split string to groups. Each of length 3.
    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]
    # cycle elements in each group. Unless group has fewer elements than 3.
    groups = [(group[-1] + group[:-1]) if len(group) == 3 else group for group in groups]
    return "".join(groups)
Generated code:  def decode_cyclic(s: str):
    """
    takes as input string encoded with encode_cyclic function. Returns decoded string.
    """
    # split string to groups. Each of length 3.
    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]
    # cycle elements in each group. Unless group has fewer elements than 3.
    groups = [(group[-1:] + group[:-1]) if len(group) == 3 else group for group in groups]
    return "".join(groups)
Generated code:  def decode_cyclic(s: str):
    """
    takes as input string encoded with encode_cyclic function. Returns decoded string.
    """
    # split string to groups. Each of length 3.
    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]
    # cycle elements in each group. Unless group has fewer elements than 3.
    groups = [(group[-1:] + group[:-1]) if len(group) == 3 else group for group in groups]
    return "".join(groups)
Retrieved Documents:  ['\n\ndef func_0(n: int):\n    \n\n    import math\n\n    def func_1(p):\n        if p < 2:\n            return False\n        for k in range(2, min(int(math.sqrt(p)) + 1, p - 1)):\n            if p % k == 0:\n                return False\n        return True\n    f = [0, 1]\n    while True:\n        f.append(f[-1] + f[-2])\n        if is_prime(f[-1]):\n            n -= 1\n        if n == 0:\n            return f[-1]\n']
Generated code:  def prime_fib(n: int) -> int:
    def is_prime(num: int) -> bool:
        if num < 2:
            return False
        for i in range(2, int(num ** 0.5) + 1):
            if num % i == 0:
                return False
        return True

    fib_sequence = [0, 1]
    while len(fib_sequence) < n:
        fib_sequence.append(fib_sequence[-1] + fib_sequence[-2])
        if is_prime(fib_sequence[-1]):
            n -= 1

    return fib_sequence[-1]
Generated code:  def prime_fib(n: int):
    """
    prime_fib returns n-th number that is a Fibonacci number and it's also prime.
    >>> prime_fib(1)
    2
    >>> prime_fib(2)
    3
    >>> prime_fib(3)
    5
    >>> prime_fib(4)
    13
    >>> prime_fib(5)
    89
    """
    def is_prime(num):
        if num < 2:
            return False
        for i in range(2, int(num**0.5) + 1):
            if num % i == 0:
                return False
        return True

    fib_numbers = [0, 1]
    while len(fib_numbers) < n:
        next_fib = fib_numbers[-1] + fib_numbers[-2]
        fib_numbers.append(next_fib)
        if is_prime(next_fib):
            n -= 1

    return fib_numbers[-1]
Generated code:  def prime_fib(n: int):
    """
    prime_fib returns n-th number that is a Fibonacci number and it's also prime.
    >>> prime_fib(1)
    2
    >>> prime_fib(2)
    3
    >>> prime_fib(3)
    5
    >>> prime_fib(4)
    13
    >>> prime_fib(5)
    89
    """
    def is_prime(num):
        if num < 2:
            return False
        for i in range(2, int(num**0.5) + 1):
            if num % i == 0:
                return False
        return True

    fib_numbers = [0, 1]
    while len(fib_numbers) < n:
        fib_numbers.append(fib_numbers[-1] + fib_numbers[-2])

    prime_fibs = [num for num in fib_numbers if is_prime(num)]
    return prime_fibs[n-1]
Retrieved Documents:  ['\n\ndef func_0(l: list):\n    \n\n    for i in range(len(l)):\n        for j in range(i + 1, len(l)):\n            for k in range(j + 1, len(l)):\n                if l[i] + l[j] + l[k] == 0:\n                    return True\n    return False\n']
Generated code:  def triples_sum_to_zero(l: list):
    """
    triples_sum_to_zero takes a list of integers as an input.
    it returns True if there are three distinct elements in the list that
    sum to zero, and False otherwise.

    >>> triples_sum_to_zero([1, 3, 5, 0])
    False
    >>> triples_sum_to_zero([1, 3, -2, 1])
    True
    >>> triples_sum_to_zero([1, 2, 3, 7])
    False
    >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])
    True
    >>> triples_sum_to_zero([1])
    False
    """

    for i in range(len(l)):
        for j in range(i + 1, len(l)):
            for k in range(j + 1, len(l)):
                if l[i] + l[j] + l[k] == 0:
                    return True
    return False
Generated code:  def triples_sum_to_zero(l: list):
    for i in range(len(l)):
        for j in range(i + 1, len(l)):
            for k in range(j + 1, len(l)):
                if l[i] + l[j] + l[k] == 0:
                    return True
    return False
Generated code:  def triples_sum_to_zero(l: list):
    for i in range(len(l)):
        for j in range(i + 1, len(l)):
            for k in range(j + 1, len(l)):
                if l[i] + l[j] + l[k] == 0:
                    return True
    return False
Retrieved Documents:  ['def func_0(X, Y, m, n): \r\n    if m == 0 or n == 0: \r\n       return 0 \r\n    elif X[m-1] == Y[n-1]: \r\n       return 1 + longest_common_subsequence(X, Y, m-1, n-1) \r\n    else: \r\n       return max(longest_common_subsequence(X, Y, m, n-1), longest_common_subsequence(X, Y, m-1, n))']
Generated code:  def car_race_collision(n: int) -> int:
    return n * (n - 1) // 2
Generated code:  def car_race_collision(n: int):
    """
    Imagine a road that's a perfectly straight infinitely long line.
    n cars are driving left to right;  simultaneously, a different set of n cars
    are driving right to left.   The two sets of cars start out being very far from
    each other.  All cars move in the same speed.  Two cars are said to collide
    when a car that's moving left to right hits a car that's moving right to left.
    However, the cars are infinitely sturdy and strong; as a result, they continue moving
    in their trajectory as if they did not collide.

    This function outputs the number of such collisions.
    """
    return n * n
Generated code:  def car_race_collision(n: int):
    return n * n
Retrieved Documents:  ['\n\ndef func_0(l: list):\n    \n\n    return [(e + 1) for e in l]\n']
Generated code:  def incr_list(l: list):
    return [e + 1 for e in l]
Generated code:  def incr_list(l: list):
    return [e + 1 for e in l]
Generated code:  def incr_list(l: list):
    return [e + 1 for e in l]
Retrieved Documents:  ['\n\ndef func_0(l: list):\n    \n\n    for i in range(len(l)):\n        for j in range(i + 1, len(l)):\n            for k in range(j + 1, len(l)):\n                if l[i] + l[j] + l[k] == 0:\n                    return True\n    return False\n']
Generated code:  def pairs_sum_to_zero(l: list):
    """
    pairs_sum_to_zero takes a list of integers as an input.
    it returns True if there are two distinct elements in the list that
    sum to zero, and False otherwise.
    >>> pairs_sum_to_zero([1, 3, 5, 0])
    False
    >>> pairs_sum_to_zero([1, 3, -2, 1])
    False
    >>> pairs_sum_to_zero([1, 2, 3, 7])
    False
    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])
    True
    >>> pairs_sum_to_zero([1])
    False
    """
    seen = set()
    for num in l:
        if -num in seen:
            return True
        seen.add(num)
    return False
Generated code:  def pairs_sum_to_zero(l):
    seen = set()
    for num in l:
        if -num in seen:
            return True
        seen.add(num)
    return False
Generated code:  def pairs_sum_to_zero(l):
    seen = set()
    for num in l:
        if -num in seen:
            return True
        seen.add(num)
    return False
Retrieved Documents:  ['\n\ndef func_0(x: int, base: int):\n    \n\n    ret = ""\n    while x > 0:\n        ret = str(x % base) + ret\n        x //= base\n    return ret\n']
Generated code:  def change_base(x: int, base: int) -> str:
    if base < 2 or base > 9:
        raise ValueError("Base must be between 2 and 9")
    
    ret = ""
    while x > 0:
        ret = str(x % base) + ret
        x //= base
    return ret
Generated code:  def change_base(x: int, base: int) -> str:
    if base < 2 or base > 9:
        raise ValueError("Base must be between 2 and 9")
    ret = ""
    while x > 0:
        ret = str(x % base) + ret
        x //= base
    return ret
Generated code:  def change_base(x: int, base: int) -> str:
    """Change numerical base of input number x to base.
    return string representation after the conversion.
    base numbers are less than 10.
    >>> change_base(8, 3)
    '22'
    >>> change_base(8, 2)
    '1000'
    >>> change_base(7, 2)
    '111'
    """
    if base == 10:
        return str(x)
    ret = ""
    while x > 0:
        ret = str(x % base) + ret
        x //= base
    return ret
Retrieved Documents:  ['def func_0(side):\r\n  area = math.sqrt(3)*(side*side)\r\n  return area']
Generated code:  import math

def triangle_area(a, h):
    """Given length of a side and high return area for a triangle.
    >>> triangle_area(5, 3)
    7.5
    """
    return 0.5 * a * h
Generated code:  def triangle_area(a, h):
    return 0.5 * a * h
Generated code:  import math

def triangle_area(a, h):
    return 0.5 * a * h
Retrieved Documents:  ['def func_0(n):\r\n  if n == 1 or n == 2:\r\n    return 1\r\n  else:\r\n    return (fibonacci(n - 1) + (fibonacci(n - 2)))']
Generated code:  def fib4(n: int) -> int:
    if n == 0:
        return 0
    elif n == 1 or n == 3:
        return 0
    elif n == 2:
        return 2
    else:
        a, b, c, d = 0, 0, 2, 0
        for _ in range(4, n + 1):
            a, b, c, d = b, c, d, a + b + c + d
        return d
Generated code:  def fib4(n: int) -> int:
    if n == 0:
        return 0
    elif n == 1:
        return 0
    elif n == 2:
        return 2
    elif n == 3:
        return 0
    else:
        a, b, c, d = 0, 0, 2, 0
        for _ in range(4, n + 1):
            a, b, c, d = b, c, d, a + b + c + d
        return d
Generated code:  def fib4(n: int) -> int:
    a, b, c, d = 0, 0, 2, 0
    for _ in range(n):
        a, b, c, d = b, c, d, a + b + c + d
    return d
Retrieved Documents:  ['\n\ndef func_0(l: list):\n    \n\n    l = sorted(l)\n    if len(l) % 2 == 1:\n        return l[len(l) // 2]\n    else:\n        return (l[len(l) // 2 - 1] + l[len(l) // 2]) / 2.0\n']
Generated code:  def median(l: list):
    l.sort()
    if len(l) % 2 == 1:
        return l[len(l) // 2]
    else:
        return (l[len(l) // 2 - 1] + l[len(l) // 2]) / 2.0
Generated code:  def median(l: list):
    l = sorted(l)
    if len(l) % 2 == 1:
        return l[len(l) // 2]
    else:
        return (l[len(l) // 2 - 1] + l[len(l) // 2]) / 2.0
Generated code:  def median(l: list):
    l = sorted(l)
    if len(l) % 2 == 1:
        return l[len(l) // 2]
    else:
        return (l[len(l) // 2 - 1] + l[len(l) // 2]) / 2.0
Retrieved Documents:  ['\n\ndef func_0(text: str):\n    \n\n    for i in range(len(text)):\n        if text[i] != text[len(text) - 1 - i]:\n            return False\n    return True\n']
Generated code:  def is_palindrome(text: str) -> bool:
    return text == text[::-1]
Generated code:  def is_palindrome(text: str) -> bool:
    return text == text[::-1]
Generated code:  def is_palindrome(text: str) -> bool:
    return text == text[::-1]
Retrieved Documents:  ['\n\ndef func_0(n: int, p: int):\n    \n\n    ret = 1\n    for i in range(n):\n        ret = (2 * ret) % p\n    return ret\n']
Generated code:  def modp(n: int, p: int) -> int:
    """Return 2^n modulo p (be aware of numerics).
    >>> modp(3, 5)
    3
    >>> modp(1101, 101)
    2
    >>> modp(0, 101)
    1
    >>> modp(3, 11)
    8
    >>> modp(100, 101)
    1
    """
    result = 1
    for _ in range(n):
        result = (result * 2) % p
    return result
Generated code:  def modp(n: int, p: int):
    """Return 2^n modulo p (be aware of numerics).
    >>> modp(3, 5)
    3
    >>> modp(1101, 101)
    2
    >>> modp(0, 101)
    1
    >>> modp(3, 11)
    8
    >>> modp(100, 101)
    1
    """
    ret = 1
    for i in range(n):
        ret = (2 * ret) % p
    return ret
Generated code:  def modp(n: int, p: int):
    """Return 2^n modulo p (be aware of numerics).
    >>> modp(3, 5)
    3
    >>> modp(1101, 101)
    2
    >>> modp(0, 101)
    1
    >>> modp(3, 11)
    8
    >>> modp(100, 101)
    1
    """
    return pow(2, n, p)
Retrieved Documents:  ['\ndef func_0(x, shift):\n    \n\n    s = str(x)\n    if shift > len(s):\n        return s[::-1]\n    else:\n        return s[len(s) - shift:] + s[:len(s) - shift]\n']
Generated code:  def decode_shift(s: str):
    """
    takes as input string encoded with encode_shift function. Returns decoded string.
    """
    return "".join([chr(((ord(ch) - 5 - ord("a")) % 26) + ord("a")) for ch in s])
Generated code:  def decode_shift(s: str):
    """
    takes as input string encoded with encode_shift function. Returns decoded string.
    """
    return "".join([chr(((ord(ch) - 5 - ord("a")) % 26) + ord("a")) for ch in s])
Generated code:  def decode_shift(s: str):
    """
    takes as input string encoded with encode_shift function. Returns decoded string.
    """
    return "".join([chr(((ord(ch) - 5 - ord("a")) % 26) + ord("a")) for ch in s])
Retrieved Documents:  ['def func_0(str1):\r\n\tvowels = ""\r\n\tfor char in str1:\r\n\t\tif char in "aeiouAEIOU":\r\n\t\t\tvowels += char\r\n\tresult_string = ""\r\n\tfor char in str1:\r\n\t\tif char in "aeiouAEIOU":\r\n\t\t\tresult_string += vowels[-1]\r\n\t\t\tvowels = vowels[:-1]\r\n\t\telse:\r\n\t\t\tresult_string += char\r\n\treturn result_string']
Generated code:  def remove_vowels(text):
    vowels = "aeiouAEIOU"
    return ''.join([char for char in text if char not in vowels])
Generated code:  def remove_vowels(text):
    vowels = "aeiouAEIOU"
    return ''.join([char for char in text if char not in vowels])
Generated code:  def remove_vowels(text):
    return ''.join([c for c in text if c.lower() not in 'aeiou'])
Retrieved Documents:  ['\n\ndef func_0(l: list, t: int):\n    \n\n    for e in l:\n        if e >= t:\n            return False\n    return True\n']
Generated code:  def below_threshold(l: list, t: int) -> bool:
    return all(e < t for e in l)
Generated code:  def below_threshold(l: list, t: int) -> bool:
    return all(e < t for e in l)
Generated code:  def below_threshold(l: list, t: int) -> bool:
    return all(e < t for e in l)
Retrieved Documents:  ['\n\ndef func_0(x: int, y: int):\n    \n\n    return x + y\n']
Generated code:  def add(x: int, y: int) -> int:
    return x + y
Generated code:  def add(x: int, y: int):
    """Add two numbers x and y
    >>> add(2, 3)
    5
    >>> add(5, 7)
    12
    """
    return x + y
Generated code:  def add(x: int, y: int) -> int:
    return x + y
Retrieved Documents:  ["def func_0(string1,string2): \r\n    size1 = len(string1) \r\n    size2 = len(string2) \r\n    temp = '' \r\n    if size1 != size2: \r\n        return False\r\n    temp = string1 + string1 \r\n    if (temp.count(string2)> 0): \r\n        return True\r\n    else: \r\n        return False"]
Generated code:  def same_chars(s0: str, s1: str) -> bool:
    return set(s0) == set(s1)
Generated code:  def same_chars(s0: str, s1: str) -> bool:
    return sorted(s0) == sorted(s1)
Generated code:  def same_chars(s0: str, s1: str) -> bool:
    return sorted(s0) == sorted(s1)
Retrieved Documents:  ['\n\ndef func_0(n: int):\n    \n\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    return fib(n - 1) + fib(n - 2)\n']
Generated code:  def fib(n: int) -> int:
    if n <= 1:
        return n
    a, b = 0, 1
    for _ in range(2, n + 1):
        a, b = b, a + b
    return b
Generated code:  def fib(n: int) -> int:
    if n <= 1:
        return n
    a, b = 0, 1
    for _ in range(2, n + 1):
        a, b = b, a + b
    return b
Generated code:  def fib(n: int):
    if n <= 1:
        return n
    else:
        return fib(n-1) + fib(n-2)
Retrieved Documents:  ["\ndef func_0(string):\n    \n\n    opening_bracket_index = []\n    closing_bracket_index = []\n    for i in range(len(string)):\n        if string[i] == '[':\n            opening_bracket_index.append(i)\n        else:\n            closing_bracket_index.append(i)\n    closing_bracket_index.reverse()\n    cnt = 0\n    i = 0\n    l = len(closing_bracket_index)\n    for idx in opening_bracket_index:\n        if i < l and idx < closing_bracket_index[i]:\n            cnt += 1\n            i += 1\n    return cnt >= 2\n\n    \n"]
Generated code:  def correct_bracketing(brackets: str) -> bool:
    stack = []
    for bracket in brackets:
        if bracket == '<':
            stack.append(bracket)
        elif bracket == '>':
            if not stack:
                return False
            stack.pop()
    return not stack
Generated code:  def correct_bracketing(brackets: str) -> bool:
    stack = []
    for bracket in brackets:
        if bracket == '<':
            stack.append(bracket)
        elif bracket == '>':
            if not stack or stack[-1]!= '<':
                return False
            stack.pop()
    return not stack
Generated code:  def correct_bracketing(brackets: str) -> bool:
    """ brackets is a string of "<" and ">".
    return True if every opening bracket has a corresponding closing bracket.

    >>> correct_bracketing("<")
    False
    >>> correct_bracketing("<>")
    True
    >>> correct_bracketing("<<><>>")
    True
    >>> correct_bracketing("><<>")
    False
    """
    stack = []
    for bracket in brackets:
        if bracket == "<":
            stack.append(bracket)
        elif bracket == ">":
            if not stack:
                return False
            stack.pop()
    return not stack
Retrieved Documents:  ['def func_0(l): \r\n    return sorted(l) == list(range(min(l),max(l)+1)) ']
Generated code:  def monotonic(l: list):
    """Return True is list elements are monotonically increasing or decreasing.
    >>> monotonic([1, 2, 4, 20])
    True
    >>> monotonic([1, 20, 4, 10])
    False
    >>> monotonic([4, 1, 0, -10])
    True
    """
    return all(l[i] <= l[i + 1] for i in range(len(l) - 1)) or all(l[i] >= l[i + 1] for i in range(len(l) - 1))
Generated code:  def monotonic(l: list):
    """Return True is list elements are monotonically increasing or decreasing.
    >>> monotonic([1, 2, 4, 20])
    True
    >>> monotonic([1, 20, 4, 10])
    False
    >>> monotonic([4, 1, 0, -10])
    True
    """
    return all(l[i] <= l[i + 1] for i in range(len(l) - 1)) or all(l[i] >= l[i + 1] for i in range(len(l) - 1))
Generated code:  def monotonic(l: list):
    """Return True is list elements are monotonically increasing or decreasing.
    >>> monotonic([1, 2, 4, 20])
    True
    >>> monotonic([1, 20, 4, 10])
    False
    >>> monotonic([4, 1, 0, -10])
    True
    """
    return all(l[i] <= l[i + 1] for i in range(len(l) - 1)) or all(l[i] >= l[i + 1] for i in range(len(l) - 1))
Retrieved Documents:  ['\n\ndef func_0(l1: list, l2: list):\n    \n\n    ret = set()\n    for e1 in l1:\n        for e2 in l2:\n            if e1 == e2:\n                ret.add(e1)\n    return sorted(list(ret))\n']
Generated code:  def common(l1: list, l2: list):
    return sorted(set(l1) & set(l2))
Generated code:  def common(l1: list, l2: list):
    return sorted(list(set(l1) & set(l2)))
Generated code:  def common(l1: list, l2: list):
    return sorted(set(l1) & set(l2))
Retrieved Documents:  ['\n\ndef func_0(n: int):\n    \n\n    def func_1(k):\n        if k < 2:\n            return False\n        for i in range(2, k - 1):\n            if k % i == 0:\n                return False\n        return True\n    largest = 1\n    for j in range(2, n + 1):\n        if n % j == 0 and is_prime(j):\n            largest = max(largest, j)\n    return largest\n']
Generated code:  def largest_prime_factor(n: int) -> int:
    """Return the largest prime factor of n. Assume n > 1 and is not a prime.
    >>> largest_prime_factor(13195)
    29
    >>> largest_prime_factor(2048)
    2
    """
    def is_prime(num):
        if num < 2:
            return False
        for i in range(2, int(num ** 0.5) + 1):
            if num % i == 0:
                return False
        return True

    largest_factor = 1
    for i in range(2, n + 1):
        if n % i == 0 and is_prime(i):
            largest_factor = max(largest_factor, i)
    return largest_factor
Generated code:  def largest_prime_factor(n: int):
    """Return the largest prime factor of n. Assume n > 1 and is not a prime.
    >>> largest_prime_factor(13195)
    29
    >>> largest_prime_factor(2048)
    2
    """
    largest = -1
    while n % 2 == 0:
        largest = 2
        n >>= 1
    for i in range(3, int(math.sqrt(n)) + 1, 2):
        while n % i == 0:
            largest = i
            n = n / i
    if n > 2:
        largest = n
    return int(largest)
Generated code:  def largest_prime_factor(n: int):
    """Return the largest prime factor of n. Assume n > 1 and is not a prime.
    >>> largest_prime_factor(13195)
    29
    >>> largest_prime_factor(2048)
    2
    """
    def is_prime(num):
        if num < 2:
            return False
        for i in range(2, int(num ** 0.5) + 1):
            if num % i == 0:
                return False
        return True

    largest = 1
    for i in range(2, n + 1):
        if n % i == 0 and is_prime(i):
            largest = max(largest, i)
    return largest
Retrieved Documents:  ['def func_0(n): \r\n    sum = 0\r\n    for i in range(1,n+1) : \r\n        sum = sum + (i*i*i*i) \r\n    return sum']
Generated code:  def sum_to_n(n: int):
    """sum_to_n is a function that sums numbers from 1 to n.
    >>> sum_to_n(30)
    465
    >>> sum_to_n(100)
    5050
    >>> sum_to_n(5)
    15
    >>> sum_to_n(10)
    55
    >>> sum_to_n(1)
    1
    """
    return n*(n+1)//2
Generated code:  def sum_to_n(n: int):
    """sum_to_n is a function that sums numbers from 1 to n.
    >>> sum_to_n(30)
    465
    >>> sum_to_n(100)
    5050
    >>> sum_to_n(5)
    15
    >>> sum_to_n(10)
    55
    >>> sum_to_n(1)
    1
    """
    return sum(range(n + 1))
Generated code:  def sum_to_n(n: int):
    """sum_to_n is a function that sums numbers from 1 to n.
    >>> sum_to_n(30)
    465
    >>> sum_to_n(100)
    5050
    >>> sum_to_n(5)
    15
    >>> sum_to_n(10)
    55
    >>> sum_to_n(1)
    1
    """
    return sum(range(n + 1))
Retrieved Documents:  ["\ndef func_0(string):\n    \n\n    opening_bracket_index = []\n    closing_bracket_index = []\n    for i in range(len(string)):\n        if string[i] == '[':\n            opening_bracket_index.append(i)\n        else:\n            closing_bracket_index.append(i)\n    closing_bracket_index.reverse()\n    cnt = 0\n    i = 0\n    l = len(closing_bracket_index)\n    for idx in opening_bracket_index:\n        if i < l and idx < closing_bracket_index[i]:\n            cnt += 1\n            i += 1\n    return cnt >= 2\n\n    \n"]
Generated code:  def correct_bracketing(brackets: str) -> bool:
    stack = []
    for bracket in brackets:
        if bracket == '(':
            stack.append(bracket)
        elif bracket == ')':
            if not stack:
                return False
            stack.pop()
    return not stack
Generated code:  def correct_bracketing(brackets: str) -> bool:
    stack = []
    for bracket in brackets:
        if bracket == "(":
            stack.append(bracket)
        elif bracket == ")":
            if not stack or stack[-1]!= "(":
                return False
            stack.pop()
    return not stack
Generated code:  def correct_bracketing(brackets: str) -> bool:
    """ brackets is a string of "(" and ")".
    return True if every opening bracket has a corresponding closing bracket.

    >>> correct_bracketing("(")
    False
    >>> correct_bracketing("()")
    True
    >>> correct_bracketing("(()())")
    True
    >>> correct_bracketing(")(()")
    False
    """
    stack = []
    for bracket in brackets:
        if bracket == "(":
            stack.append(bracket)
        elif bracket == ")":
            if not stack:
                return False
            stack.pop()
    return not stack
Retrieved Documents:  ['import math\n\n\ndef func_0(xs: list, x: float):\n    \n    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])\n\n\ndef func_1(xs: list):\n    \n\n    begin, end = -1., 1.\n    while poly(xs, begin) * poly(xs, end) > 0:\n        begin *= 2.0\n        end *= 2.0\n    while end - begin > 1e-10:\n        center = (begin + end) / 2.0\n        if poly(xs, center) * poly(xs, begin) > 0:\n            begin = center\n        else:\n            end = center\n    return begin\n']
Generated code:  def derivative(xs: list):
    """ xs represent coefficients of a polynomial.
    xs[0] + xs[1] * x + xs[2] * x^2 +....
     Return derivative of this polynomial in the same form.
    >>> derivative([3, 1, 2, 4, 5])
    [1, 4, 12, 20]
    >>> derivative([1, 2, 3])
    [2, 6]
    """
    return [xs[i] * i for i in range(1, len(xs))]
Generated code:  def derivative(xs: list):
    return [i * x for i, x in enumerate(xs)][1:]
Generated code:  def derivative(xs: list):
    return [i * x for i, x in enumerate(xs)][1:]
Retrieved Documents:  ['\n\ndef func_0(n: int):\n    \n\n    if n == 0:\n        return 0\n    if n == 1:\n        return 0\n    if n == 2:\n        return 1\n    return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)\n']
Generated code:  def fibfib(n: int) -> int:
    if n == 0 or n == 1:
        return 0
    elif n == 2:
        return 1
    else:
        a, b, c = 0, 0, 1
        for _ in range(3, n + 1):
            a, b, c = b, c, a + b + c
        return c
Generated code:  def fibfib(n: int) -> int:
    if n == 0:
        return 0
    elif n == 1:
        return 0
    elif n == 2:
        return 1
    else:
        a, b, c = 0, 0, 1
        for _ in range(3, n + 1):
            a, b, c = b, c, a + b + c
        return c
Generated code:  def fibfib(n: int) -> int:
    if n == 0:
        return 0
    elif n == 1:
        return 0
    elif n == 2:
        return 1
    else:
        a, b, c = 0, 0, 1
        for _ in range(3, n + 1):
            a, b, c = b, c, a + b + c
        return c
Retrieved Documents:  ['\nFIX = \n\ndef func_0(s):\n    \n\n    vowels = "aeiouAEIOU"\n    n_vowels = sum(c in vowels for c in s)\n    if s[-1] == \'y\' or s[-1] == \'Y\':\n        n_vowels += 1\n    return n_vowels\n']
Generated code:  def vowels_count(s):
    """Write a function vowels_count which takes a string representing
    a word as input and returns the number of vowels in the string.
    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a
    vowel, but only when it is at the end of the given word.

    Example:
    >>> vowels_count("abcde")
    2
    >>> vowels_count("ACEDY")
    3
    """
    vowels = "aeiouAEIOU"
    n_vowels = sum(c in vowels for c in s)
    if s[-1] == 'y' or s[-1] == 'Y':
        n_vowels += 1
    return n_vowels
Generated code:  def vowels_count(s):
    """Write a function vowels_count which takes a string representing
    a word as input and returns the number of vowels in the string.
    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a
    vowel, but only when it is at the end of the given word.

    Example:
    >>> vowels_count("abcde")
    2
    >>> vowels_count("ACEDY")
    3
    """
    vowels = "aeiouAEIOU"
    n_vowels = sum(c in vowels for c in s)
    if s[-1] == 'y' or s[-1] == 'Y':
        n_vowels += 1
    return n_vowels
Generated code:  def vowels_count(s):
    vowels = "aeiouAEIOU"
    n_vowels = sum(c in vowels for c in s)
    if s[-1] == 'y' or s[-1] == 'Y':
        n_vowels += 1
    return n_vowels
Retrieved Documents:  ['\ndef func_0(x, shift):\n    \n\n    s = str(x)\n    if shift > len(s):\n        return s[::-1]\n    else:\n        return s[len(s) - shift:] + s[:len(s) - shift]\n']
Generated code:  def circular_shift(x, shift):
    s = str(x)
    if shift > len(s):
        return s[::-1]
    else:
        return s[-shift:] + s[:-shift]
Generated code:  def circular_shift(x, shift):
    s = str(x)
    if shift > len(s):
        return s[::-1]
    else:
        return s[len(s) - shift:] + s[:len(s) - shift]
Generated code:  def circular_shift(x, shift):
    s = str(x)
    if shift > len(s):
        return s[::-1]
    else:
        return s[len(s) - shift:] + s[:len(s) - shift]
Retrieved Documents:  ['\ndef func_0(s):\n    \n\n    if s == "": return 0\n    return sum(ord(char) if char.isupper() else 0 for char in s)\n']
Generated code:  def digitSum(s):
    return sum(ord(char) for char in s if char.isupper())
Generated code:  def digitSum(s):
    return sum(ord(char) for char in s if char.isupper())
Generated code:  def digitSum(s):
    return sum(ord(c) for c in s if c.isupper())
Retrieved Documents:  ["def func_0(s,n): \r\n    count=0\r\n    for i in range(0,n): \r\n        if (s[i] == '1'): \r\n            count = count + 1\r\n    return count "]
Generated code:  def fruit_distribution(s, n):
    numbers = [int(num) for num in s.split() if num.isdigit()]
    return n - sum(numbers)
Generated code:  def fruit_distribution(s,n):
    count = 0
    for i in range(0,n):
        if (s[i] ==''):
            count += 1
    return n - count - 2
Generated code:  def fruit_distribution(s, n):
    return n - sum(int(num) for num in s.split() if num.isdigit())
Retrieved Documents:  ['\ndef func_0(arr):\n    \n\n    if(len(arr) == 0): return []\n    evens = list(filter(lambda x: x%2 == 0, arr))\n    if(evens == []): return []\n    return [min(evens), arr.index(min(evens))]\n']
Generated code:  def pluck(arr):
    """
    Given an array representing a branch of a tree that has non-negative integer nodes
    your task is to pluck one of the nodes and return it.
    The plucked node should be the node with the smallest even value.
    If multiple nodes with the same smallest even value are found return the node that has smallest index.

    The plucked node should be returned in a list, [ smalest_value, its index ],
    If there are no even values or the given array is empty, return [].

    Example 1:
        Input: [4,2,3]
        Output: [2, 1]
        Explanation: 2 has the smallest even value, and 2 has the smallest index.

    Example 2:
        Input: [1,2,3]
        Output: [2, 1]
        Explanation: 2 has the smallest even value, and 2 has the smallest index. 

    Example 3:
        Input: []
        Output: []
    
    Example 4:
        Input: [5, 0, 3, 0, 4, 2]
        Output: [0, 1]
        Explanation: 0 is the smallest value, but  there are two zeros,
                     so we will choose the first zero, which has the smallest index.

    Constraints:
        * 1 <= nodes.length <= 10000
        * 0 <= node.value
    """
    if not arr:
        return []
    evens = [x for x in arr if x % 2 == 0]
    if not evens:
        return []
    return [min(evens), arr.index(min(evens))]
Generated code:  def pluck(arr):
    if not arr:
        return []
    evens = [x for x in arr if x % 2 == 0]
    if not evens:
        return []
    return [min(evens), arr.index(min(evens))]
Generated code:  def pluck(arr):
    if not arr:
        return []
    evens = [n for n in arr if n % 2 == 0]
    if not evens:
        return []
    return [min(evens), arr.index(min(evens))]
Retrieved Documents:  ['\ndef func_0(lst):\n    \n\n    frq = [0] * (max(lst) + 1)\n    for i in lst:\n        frq[i] += 1;\n\n    ans = -1\n    for i in range(1, len(frq)):\n        if frq[i] >= i:\n            ans = i\n    \n    return ans\n']
Generated code:  def search(lst):
    '''
    You are given a non-empty list of positive integers. Return the greatest integer that is greater than 
    zero, and has a frequency greater than or equal to the value of the integer itself. 
    The frequency of an integer is the number of times it appears in the list.
    If no such a value exist, return -1.
    Examples:
        search([4, 1, 2, 2, 3, 1]) == 2
        search([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3
        search([5, 5, 4, 4, 4]) == -1
    '''

    frq = [0] * (max(lst) + 1)
    for i in lst:
        frq[i] += 1;

    ans = -1
    for i in range(1, len(frq)):
        if frq[i] >= i:
            ans = i
    
    return ans
Generated code:  def search(lst):
    frq = [0] * (max(lst) + 1)
    for i in lst:
        frq[i] += 1;

    ans = -1
    for i in range(1, len(frq)):
        if frq[i] >= i:
            ans = i
    
    return ans
Generated code:  def search(lst):
    frq = [0] * (max(lst) + 1)
    for i in lst:
        frq[i] += 1;

    ans = -1
    for i in range(1, len(frq)):
        if frq[i] >= i:
            ans = i
    
    return ans
Retrieved Documents:  ['def func_0(l): \r\n    return sorted(l) == list(range(min(l),max(l)+1)) ']
Generated code:  def strange_sort_list(lst):
    result = []
    while lst:
        result.append(min(lst))
        lst.remove(min(lst))
        if lst:
            result.append(max(lst))
            lst.remove(max(lst))
    return result
Generated code:  def strange_sort_list(lst):
    lst.sort()
    result = []
    while lst:
        result.append(lst.pop(0))
        if lst:
            result.append(lst.pop())
    return result
Generated code:  def strange_sort_list(lst):
    sorted_lst = sorted(lst)
    result = []
    while sorted_lst:
        result.append(sorted_lst.pop(0))
        if sorted_lst:
            result.append(sorted_lst.pop())
    return result
Retrieved Documents:  ['\ndef func_0(a, b, c):\n    \n\n    if a + b <= c or a + c <= b or b + c <= a:\n        return -1 \n    s = (a + b + c)/2    \n    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n    area = round(area, 2)\n    return area\n']
Generated code:  def triangle_area(a, b, c):
    if a + b <= c or a + c <= b or b + c <= a:
        return -1 
    s = (a + b + c)/2    
    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5
    area = round(area, 2)
    return area
Generated code:  def triangle_area(a, b, c):
    if a + b <= c or a + c <= b or b + c <= a:
        return -1 
    s = (a + b + c)/2    
    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5
    area = round(area, 2)
    return area
Generated code:  def triangle_area(a, b, c):
    if a + b <= c or a + c <= b or b + c <= a:
        return -1 
    s = (a + b + c)/2    
    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5
    area = round(area, 2)
    return area
Retrieved Documents:  ['\ndef func_0(q,w):\n    \n\n    if sum(q) > w:\n        return False\n\n    i, j = 0, len(q)-1\n    while i<j:\n        if q[i] != q[j]:\n            return False\n        i+=1\n        j-=1\n    return True\n']
Generated code:  def will_it_fly(q, w):
    return sum(q) <= w and q == q[::-1]
Generated code:  def will_it_fly(q, w):
    if sum(q) > w:
        return False
    i, j = 0, len(q) - 1
    while i < j:
        if q[i]!= q[j]:
            return False
        i += 1
        j -= 1
    return True
Generated code:  def will_it_fly(q,w):
    if sum(q) > w:
        return False

    i, j = 0, len(q)-1
    while i<j:
        if q[i]!= q[j]:
            return False
        i+=1
        j-=1
    return True
Retrieved Documents:  ['def func_0(arr,n): \r\n    arr = sorted(arr) \r\n    diff = 10**20 \r\n    for i in range(n-1): \r\n        if arr[i+1] - arr[i] < diff: \r\n            diff = arr[i+1] - arr[i]  \r\n    return diff ']
Generated code:  def smallest_change(arr):
    left, right = 0, len(arr) - 1
    changes = 0
    while left < right:
        if arr[left]!= arr[right]:
            changes += 1
        left += 1
        right -= 1
    return changes
Generated code:  def smallest_change(arr):
    left, right = 0, len(arr) - 1
    changes = 0
    while left < right:
        if arr[left]!= arr[right]:
            changes += 1
        left += 1
        right -= 1
    return changes
Generated code:  def smallest_change(arr):
    changes = 0
    i, j = 0, len(arr) - 1
    while i < j:
        if arr[i]!= arr[j]:
            changes += 1
        i += 1
        j -= 1
    return changes
Retrieved Documents:  ['\ndef func_0(lst1, lst2):\n    \n\n    l1 = 0\n    for st in lst1:\n        l1 += len(st)\n    \n    l2 = 0\n    for st in lst2:\n        l2 += len(st)\n    \n    if l1 <= l2:\n        return lst1\n    else:\n        return lst2\n']
Generated code:  def total_match(lst1, lst2):
    l1 = sum(len(st) for st in lst1)
    l2 = sum(len(st) for st in lst2)
    return lst1 if l1 <= l2 else lst2
Generated code:  def total_match(lst1, lst2):
    l1_chars = sum(len(s) for s in lst1)
    l2_chars = sum(len(s) for s in lst2)
    return lst1 if l1_chars <= l2_chars else lst2
Generated code:  def total_match(lst1, lst2):
    l1 = sum(len(st) for st in lst1)
    l2 = sum(len(st) for st in lst2)
    return lst1 if l1 <= l2 else lst2
Retrieved Documents:  ['\ndef func_0(a):\n    \n\n    def func_1(n):\n        for j in range(2,n):\n            if n%j == 0:\n                return False\n        return True\n\n    for i in range(2,101):\n        if not is_prime(i): continue\n        for j in range(2,101):\n            if not is_prime(j): continue\n            for k in range(2,101):\n                if not is_prime(k): continue\n                if i*j*k == a: return True\n    return False\n']
Generated code:  def is_multiply_prime(a):
    def is_prime(n):
        if n < 2:
            return False
        for i in range(2, int(n**0.5) + 1):
            if n % i == 0:
                return False
        return True

    for i in range(2, 101):
        if not is_prime(i):
            continue
        for j in range(i + 1, 101):  # start from i + 1 to avoid duplicate factors
            if not is_prime(j):
                continue
            for k in range(j + 1, 101):  # start from j + 1 to avoid duplicate factors
                if not is_prime(k):
                    continue
                if i * j * k == a:
                    return True
    return False
Generated code:  def is_multiply_prime(a):
    def is_prime(n):
        if n < 2:
            return False
        for i in range(2, int(n**0.5) + 1):
            if n % i == 0:
                return False
        return True

    for i in range(2, 101):
        if not is_prime(i):
            continue
        for j in range(i, 101):  # Start from i to avoid duplicate checks
            if not is_prime(j):
                continue
            for k in range(j, 101):  # Start from j to avoid duplicate checks
                if not is_prime(k):
                    continue
                if i * j * k == a:
                    return True
    return False
Generated code:  def is_multiply_prime(a):
    def is_prime(n):
        if n < 2:
            return False
        for i in range(2, int(n**0.5) + 1):
            if n % i == 0:
                return False
        return True

    for i in range(2, 101):
        if not is_prime(i):
            continue
        for j in range(i, 101):
            if not is_prime(j):
                continue
            for k in range(j, 101):
                if not is_prime(k):
                    continue
                if i * j * k == a:
                    return True
    return False
Retrieved Documents:  ['\ndef func_0(x, n):\n    \n\n    if (n == 1): \n        return (x == 1) \n    power = 1\n    while (power < x): \n        power = power * n \n    return (power == x) \n']
Generated code:  def is_simple_power(x, n):
    if n == 1:
        return x == 1
    power = 1
    while power < x:
        power *= n
    return power == x
Generated code:  def is_simple_power(x, n):
    """Your task is to write a function that returns true if a number x is a simple
    power of n and false in other cases.
    x is a simple power of n if n**int=x
    For example:
    is_simple_power(1, 4) => true
    is_simple_power(2, 2) => true
    is_simple_power(8, 2) => true
    is_simple_power(3, 2) => false
    is_simple_power(3, 1) => false
    is_simple_power(5, 3) => false
    """
    if n == 1:
        return x == 1
    power = 1
    while power < x:
        power *= n
    return power == x
Generated code:  def is_simple_power(x, n):
    if n == 1:
        return x == 1
    power = 1
    while power < x:
        power *= n
    return power == x
Retrieved Documents:  ['\ndef func_0(a):\n    \n\n    def func_1(n):\n        for j in range(2,n):\n            if n%j == 0:\n                return False\n        return True\n\n    for i in range(2,101):\n        if not is_prime(i): continue\n        for j in range(2,101):\n            if not is_prime(j): continue\n            for k in range(2,101):\n                if not is_prime(k): continue\n                if i*j*k == a: return True\n    return False\n']
Generated code:  def iscube(a):
    if a < 0:
        a = -a
    for i in range(1, int(a**(1/3)) + 1):
        if i**3 == a:
            return True
    return False
Generated code:  def iscube(a):
    if a == 0:
        return True
    abs_a = abs(a)
    cube_root = abs_a ** (1/3)
    return round(cube_root) ** 3 == abs_a
Generated code:  def iscube(a):
    if a < 0:
        a = -a
    i = 1
    while i * i * i <= a:
        if i * i * i == a:
            return True
        i += 1
    return False
Retrieved Documents:  ["\ndef func_0(num):\n    \n\n    primes = ('2', '3', '5', '7', 'B', 'D')\n    total = 0\n    for i in range(0, len(num)):\n        if num[i] in primes:\n            total += 1\n    return total\n"]
Generated code:  def hex_key(num):
    primes = {'2', '3', '5', '7', 'B', 'D'}
    return sum(1 for digit in num if digit in primes)
Generated code:  def hex_key(num):
    primes = ('2', '3', '5', '7', 'B', 'D')
    total = 0
    for i in range(0, len(num)):
        if num[i] in primes:
            total += 1
    return total
Generated code:  def hex_key(num):
    primes = ('2', '3', '5', '7', 'B', 'D')
    total = 0
    for i in range(0, len(num)):
        if num[i] in primes:
            total += 1
    return total
Retrieved Documents:  ['\ndef func_0(decimal):\n    \n\n    return "db" + bin(decimal)[2:] + "db"\n']
Generated code:  def decimal_to_binary(decimal):
    return "db" + bin(decimal)[2:] + "db"
Generated code:  def decimal_to_binary(decimal):
    return "db" + bin(decimal)[2:] + "db"
Generated code:  def decimal_to_binary(decimal):
    return "db" + bin(decimal)[2:] + "db"
Retrieved Documents:  ["def func_0(s): \r\n    s = s.split(' ')   \r\n    for word in s:    \r\n        if len(word)%2!=0: \r\n            return True  \r\n        else:\r\n          return False"]
Generated code:  def is_happy(s):
    if len(s) < 3:
        return False
    for i in range(len(s) - 2):
        if len(set(s[i:i+3])) < 3:
            return False
    return True
Generated code:  def is_happy(s):
    if len(s) < 3:
        return False
    for i in range(len(s) - 2):
        if len(set(s[i:i+3])) < 3:
            return False
    return True
Generated code:  def is_happy(s):
    if len(s) < 3:
        return False
    for i in range(len(s) - 2):
        if len(set(s[i:i+3])) < 3:
            return False
    return True
Retrieved Documents:  ['\ndef func_0(grades):\n    \n\n\n   \n    letter_grade = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grade.append("A+")\n        elif gpa > 3.7:\n            letter_grade.append("A")\n        elif gpa > 3.3:\n            letter_grade.append("A-")\n        elif gpa > 3.0:\n            letter_grade.append("B+")\n        elif gpa > 2.7:\n            letter_grade.append("B")\n        elif gpa > 2.3:\n            letter_grade.append("B-")\n        elif gpa > 2.0:\n            letter_grade.append("C+")\n        elif gpa > 1.7:\n            letter_grade.append("C")\n        elif gpa > 1.3:\n            letter_grade.append("C-")\n        elif gpa > 1.0:\n            letter_grade.append("D+")\n        elif gpa > 0.7:\n            letter_grade.append("D")\n        elif gpa > 0.0:\n            letter_grade.append("D-")\n        else:\n            letter_grade.append("E")\n    return letter_grade\n']
Generated code:  def numerical_letter_grade(grades):
    letter_grade = []
    for gpa in grades:
        if gpa == 4.0:
            letter_grade.append("A+")
        elif gpa > 3.7:
            letter_grade.append("A")
        elif gpa > 3.3:
            letter_grade.append("A-")
        elif gpa > 3.0:
            letter_grade.append("B+")
        elif gpa > 2.7:
            letter_grade.append("B")
        elif gpa > 2.3:
            letter_grade.append("B-")
        elif gpa > 2.0:
            letter_grade.append("C+")
        elif gpa > 1.7:
            letter_grade.append("C")
        elif gpa > 1.3:
            letter_grade.append("C-")
        elif gpa > 1.0:
            letter_grade.append("D+")
        elif gpa > 0.7:
            letter_grade.append("D")
        elif gpa > 0.0:
            letter_grade.append("D-")
        else:
            letter_grade.append("E")
    return letter_grade
Generated code:  def numerical_letter_grade(grades):
    """It is the last week of the semester and the teacher has to give the grades
    to students. The teacher has been making her own algorithm for grading.
    The only problem is, she has lost the code she used for grading.
    She has given you a list of GPAs for some students and you have to write 
    a function that can output a list of letter grades using the following table:
             GPA       |    Letter grade
              4.0                A+
            > 3.7                A 
            > 3.3                A- 
            > 3.0                B+
            > 2.7                B 
            > 2.3                B-
            > 2.0                C+
            > 1.7                C
            > 1.3                C-
            > 1.0                D+ 
            > 0.7                D 
            > 0.0                D-
              0.0                E
    

    Example:
    grade_equation([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']
    """

    letter_grade = []
    for gpa in grades:
        if gpa == 4.0:
            letter_grade.append("A+")
        elif gpa > 3.7:
            letter_grade.append("A")
        elif gpa > 3.3:
            letter_grade.append("A-")
        elif gpa > 3.0:
            letter_grade.append("B+")
        elif gpa > 2.7:
            letter_grade.append("B")
        elif gpa > 2.3:
            letter_grade.append("B-")
        elif gpa > 2.0:
            letter_grade.append("C+")
        elif gpa > 1.7:
            letter_grade.append("C")
        elif gpa >
Generated code:  def numerical_letter_grade(grades):
    """It is the last week of the semester and the teacher has to give the grades
    to students. The teacher has been making her own algorithm for grading.
    The only problem is, she has lost the code she used for grading.
    She has given you a list of GPAs for some students and you have to write 
    a function that can output a list of letter grades using the following table:
             GPA       |    Letter grade
              4.0                A+
            > 3.7                A 
            > 3.3                A- 
            > 3.0                B+
            > 2.7                B 
            > 2.3                B-
            > 2.0                C+
            > 1.7                C
            > 1.3                C-
            > 1.0                D+ 
            > 0.7                D 
            > 0.0                D-
              0.0                E
    

    Example:
    grade_equation([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']
    """

    letter_grade = []
    for gpa in grades:
        if gpa == 4.0:
            letter_grade.append("A+")
        elif gpa > 3.7:
            letter_grade.append("A")
        elif gpa > 3.3:
            letter_grade.append("A-")
        elif gpa > 3.0:
            letter_grade.append("B+")
        elif gpa > 2.7:
            letter_grade.append("B")
        elif gpa > 2.3:
            letter_grade.append("B-")
        elif gpa > 2.0:
            letter_grade.append("C+")
        elif gpa > 1.7:
            letter_grade.append("C")
        elif gpa >
Retrieved Documents:  ['\ndef func_0(string):\n    \n\n    l = len(string)\n    if l == 0 or l == 1:\n        return False\n    for i in range(2, l):\n        if l % i == 0:\n            return False\n    return True\n']
Generated code:  def prime_length(string):
    """Write a function that takes a string and returns True if the string
    length is a prime number or False otherwise
    Examples
    prime_length('Hello') == True
    prime_length('abcdcba') == True
    prime_length('kittens') == True
    prime_length('orange') == False
    """
    length = len(string)
    if length < 2:
        return False
    for i in range(2, int(length**0.5) + 1):
        if length % i == 0:
            return False
    return True
Generated code:  def prime_length(string):
    """Write a function that takes a string and returns True if the string
    length is a prime number or False otherwise
    Examples
    prime_length('Hello') == True
    prime_length('abcdcba') == True
    prime_length('kittens') == True
    prime_length('orange') == False
    """
    def is_prime(n):
        if n <= 1:
            return False
        if n <= 3:
            return True
        if n % 2 == 0 or n % 3 == 0:
            return False
        i = 5
        while i * i <= n:
            if n % i == 0 or n % (i + 2) == 0:
                return False
            i += 6
        return True

    return is_prime(len(string))
Generated code:  def prime_length(string):
    length = len(string)
    if length < 2:
        return False
    for i in range(2, int(length ** 0.5) + 1):
        if length % i == 0:
            return False
    return True
Retrieved Documents:  ["def func_0(s,n): \r\n    count=0\r\n    for i in range(0,n): \r\n        if (s[i] == '1'): \r\n            count = count + 1\r\n    return count "]
Generated code:  def starts_one_ends(n):
    if n == 1:
        return 1
    else:
        return 18 * (10 ** (n - 2))
Generated code:  def starts_one_ends(n):
    if n == 1:
        return 1
    else:
        return 2 * (10 ** (n - 1)) - 10 ** (n - 2)
Generated code:  def starts_one_ends(n):
    """
    Given a positive integer n, return the count of the numbers of n-digit
    positive integers that start or end with 1.
    """
    if n == 1:
        return 1
    return 2 * (10 ** (n - 1)) - 10 ** (n - 2)
Retrieved Documents:  ['def func_0(n):\r\n  if n == 0:\r\n    return 0\r\n  else:\r\n    return n % 10 + sum_digits(int(n / 10))']
Generated code:  def solve(N):
    return bin(sum(int(digit) for digit in str(N)))[2:]
Generated code:  def solve(N):
    return bin(sum(int(i) for i in str(N)))[2:]
Generated code:  def solve(N):
    return bin(sum(int(i) for i in str(N)))[2:]
Retrieved Documents:  ['\ndef func_0(lst):\n    \n\n    res = []\n    for arr in lst:\n        n = sum(int(d)%2==1 for d in arr)\n        res.append("the number of odd elements " + str(n) + "n the str"+ str(n) +"ng "+ str(n) +" of the "+ str(n) +"nput.")\n    return res\n']
Generated code:  def add(lst):
    """Given a non-empty list of integers lst. add the even elements that are at odd indices..

    Examples:
        add([4, 2, 6, 7]) ==> 2 
    """
    return sum(lst[i] for i in range(1, len(lst), 2) if lst[i] % 2 == 0)
Generated code:  def add(lst):
    return sum(lst[i] for i in range(1, len(lst), 2) if lst[i] % 2 == 0)
Generated code:  def add(lst):
    return sum(lst[i] for i in range(1, len(lst), 2) if lst[i] % 2 == 0)
Retrieved Documents:  ["def func_0(s):\r\n\tchars = s\r\n\tcount_left = 0\r\n\tcount_right = 0\r\n\tswap = 0\r\n\timbalance = 0; \r\n\tfor i in range(len(chars)):\r\n\t\tif chars[i] == '[':\r\n\t\t\tcount_left += 1\r\n\t\t\tif imbalance > 0:\r\n\t\t\t\tswap += imbalance\r\n\t\t\t\timbalance -= 1\r\n\t\telif chars[i] == ']':\r\n\t\t\tcount_right += 1\r\n\t\t\timbalance = (count_right - count_left) \r\n\treturn swap"]
Generated code:  def anti_shuffle(s):
    words = s.split(' ')
    ordered_words = []
    for word in words:
        ordered_word = ''.join(sorted(word))
        ordered_words.append(ordered_word)
    return''.join(ordered_words)
Generated code:  def anti_shuffle(s):
    words = s.split()
    ordered_words = []
    for word in words:
        ordered_word = ''.join(sorted(word))
        ordered_words.append(ordered_word)
    return''.join(ordered_words)
Generated code:  def anti_shuffle(s):
    words = s.split()
    ordered_words = []
    for word in words:
        ordered_word = ''.join(sorted(word))
        ordered_words.append(ordered_word)
    return''.join(ordered_words)
Retrieved Documents:  ['\ndef func_0(lst, x):\n    \n\n    coords = [(i, j) for i in range(len(lst)) for j in range(len(lst[i])) if lst[i][j] == x]\n    return sorted(sorted(coords, key=lambda x: x[1], reverse=True), key=lambda x: x[0])\n']
Generated code:  def get_row(lst, x):
    """
    You are given a 2 dimensional data, as a nested lists,
    which is similar to matrix, however, unlike matrices,
    each row may contain a different number of columns.
    Given lst, and integer x, find integers x in the list,
    and return list of tuples, [(x1, y1), (x2, y2)...] such that
    each tuple is a coordinate - (row, columns), starting with 0.
    Sort coordinates initially by rows in ascending order.
    Also, sort coordinates of the row by columns in descending order.
    
    Examples:
    get_row([
      [1,2,3,4,5,6],
      [1,2,3,4,1,6],
      [1,2,3,4,5,1]
    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]
    get_row([], 1) == []
    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]
    """
    coords = [(i, j) for i in range(len(lst)) for j in range(len(lst[i])) if lst[i][j] == x]
    return sorted(sorted(coords, key=lambda x: x[1], reverse=True), key=lambda x: x[0])
Generated code:  def get_row(lst, x):
    coords = [(i, j) for i in range(len(lst)) for j in range(len(lst[i])) if lst[i][j] == x]
    return sorted(sorted(coords, key=lambda x: x[1], reverse=True), key=lambda x: x[0])
Generated code:  def get_row(lst, x):
    coords = [(i, j) for i in range(len(lst)) for j in range(len(lst[i])) if lst[i][j] == x]
    return sorted(sorted(coords, key=lambda x: x[1], reverse=True), key=lambda x: x[0])
Retrieved Documents:  ['\ndef func_0(array):\n    \n\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0) \n']
Generated code:  def sort_array(array):
    return sorted(array) if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)
Generated code:  def sort_array(array):
    if not array:
        return []
    
    is_odd = (array[0] + array[-1]) % 2 == 1
    return sorted(array, reverse=is_odd)
Generated code:  def sort_array(array):
    if not array:
        return []
    
    is_odd = (array[0] + array[-1]) % 2!= 0
    return sorted(array, reverse=is_odd)
Retrieved Documents:  ["\ndef func_0(s):\n    \n\n    d = 'abcdefghijklmnopqrstuvwxyz'\n    out = ''\n    for c in s:\n        if c in d:\n            out += d[(d.index(c)+2*2) % 26]\n        else:\n            out += c\n    return out\n"]
Generated code:  def encrypt(s):
    """Create a function encrypt that takes a string as an argument and
    returns a string encrypted with the alphabet being rotated. 
    The alphabet should be rotated in a manner such that the letters 
    shift down by two multiplied to two places.
    For example:
    encrypt('hi') returns 'lm'
    encrypt('asdfghjkl') returns 'ewhjklnop'
    encrypt('gf') returns 'kj'
    encrypt('et') returns 'ix'
    """
    d = 'abcdefghijklmnopqrstuvwxyz'
    out = ''
    for c in s:
        if c in d:
            out += d[(d.index(c)+2*2) % 26]
        else:
            out += c
    return out
Generated code:  def encrypt(s):
    """Create a function encrypt that takes a string as an argument and
    returns a string encrypted with the alphabet being rotated. 
    The alphabet should be rotated in a manner such that the letters 
    shift down by two multiplied to two places.
    For example:
    encrypt('hi') returns 'lm'
    encrypt('asdfghjkl') returns 'ewhjklnop'
    encrypt('gf') returns 'kj'
    encrypt('et') returns 'ix'
    """
    d = 'abcdefghijklmnopqrstuvwxyz'
    out = ''
    for c in s:
        if c in d:
            out += d[(d.index(c)+2*2) % 26]
        else:
            out += c
    return out
Generated code:  def encrypt(s):
    """Create a function encrypt that takes a string as an argument and
    returns a string encrypted with the alphabet being rotated. 
    The alphabet should be rotated in a manner such that the letters 
    shift down by two multiplied to two places.
    For example:
    encrypt('hi') returns 'lm'
    encrypt('asdfghjkl') returns 'ewhjklnop'
    encrypt('gf') returns 'kj'
    encrypt('et') returns 'ix'
    """

    d = 'abcdefghijklmnopqrstuvwxyz'
    out = ''
    for c in s:
        if c in d:
            out += d[(d.index(c)+2*2) % 26]
        else:
            out += c
    return out
Retrieved Documents:  ['def func_0(lst): \r\n    minList = min((x) for x in lst) \r\n    return minList']
Generated code:  def next_smallest(lst):
    if len(lst) < 2:
        return None
    lst.sort()
    return lst[1]
Generated code:  def next_smallest(lst):
    if len(lst) < 2:
        return None
    lst.sort()
    return lst[1]
Generated code:  def next_smallest(lst):
    if len(lst) < 2:
        return None
    lst.sort()
    return lst[1]
Retrieved Documents:  ["\ndef func_0(S):\n    \n\n    import re\n    sentences = re.split(r'[.?!]\\s*', S)\n    return sum(sentence[0:2] == 'I ' for sentence in sentences)\n"]
Generated code:  def is_bored(S):
    """
    You'll be given a string of words, and your task is to count the number
    of boredoms. A boredom is a sentence that starts with the word "I".
    Sentences are delimited by '.', '?' or '!'.
   
    For example:
    >>> is_bored("Hello world")
    0
    >>> is_bored("The sky is blue. The sun is shining. I love this weather")
    1
    """
    import re
    sentences = re.split(r'[.?!]\s*', S)
    return sum(sentence.startswith('I ') for sentence in sentences)
Generated code:  def is_bored(S):
    """
    You'll be given a string of words, and your task is to count the number
    of boredoms. A boredom is a sentence that starts with the word "I".
    Sentences are delimited by '.', '?' or '!'.
   
    For example:
    >>> is_bored("Hello world")
    0
    >>> is_bored("The sky is blue. The sun is shining. I love this weather")
    1
    """
    import re
    sentences = re.split(r'[.?!]\s*', S)
    return sum(sentence[0:2] == 'I'for sentence in sentences)
Generated code:  def is_bored(S):
    """
    You'll be given a string of words, and your task is to count the number
    of boredoms. A boredom is a sentence that starts with the word "I".
    Sentences are delimited by '.', '?' or '!'.
   
    For example:
    >>> is_bored("Hello world")
    0
    >>> is_bored("The sky is blue. The sun is shining. I love this weather")
    1
    """

    import re
    sentences = re.split(r'[.?!]\s*', S)
    return sum(sentence[0:2] == 'I'for sentence in sentences)
Retrieved Documents:  ['\ndef func_0(x, y, z):\n    \n\n    \n    if isinstance(x,int) and isinstance(y,int) and isinstance(z,int):\n        if (x+y==z) or (x+z==y) or (y+z==x):\n            return True\n        return False\n    return False\n']
Generated code:  def any_int(x, y, z):
    return isinstance(x, int) and isinstance(y, int) and isinstance(z, int) and (x + y == z or x + z == y or y + z == x)
Generated code:  def any_int(x, y, z):
    if isinstance(x, int) and isinstance(y, int) and isinstance(z, int):
        return x + y == z or x + z == y or y + z == x
    return False
Generated code:  def any_int(x, y, z):
    if isinstance(x,int) and isinstance(y,int) and isinstance(z,int):
        if (x+y==z) or (x+z==y) or (y+z==x):
            return True
        return False
    return False
Retrieved Documents:  ['\ndef func_0(message):\n    \n\n    vowels = "aeiouAEIOU"\n    vowels_replace = dict([(i, chr(ord(i) + 2)) for i in vowels])\n    message = message.swapcase()\n    return \'\'.join([vowels_replace[i] if i in vowels else i for i in message])\n']
Generated code:  def encode(message):
    vowels = "aeiouAEIOU"
    vowels_replace = dict([(i, chr(ord(i) + 2)) for i in vowels])
    message = message.swapcase()
    return ''.join([vowels_replace[i] if i in vowels else i for i in message])
Generated code:  def encode(message):
    """
    Write a function that takes a message, and encodes in such a 
    way that it swaps case of all letters, replaces all vowels in 
    the message with the letter that appears 2 places ahead of that 
    vowel in the english alphabet. 
    Assume only letters. 
    
    Examples:
    >>> encode('test')
    'TGST'
    >>> encode('This is a message')
    'tHKS KS C MGSSCGG'
    """
    vowels = "aeiouAEIOU"
    vowels_replace = dict([(i, chr(ord(i) + 2)) for i in vowels])
    message = message.swapcase()
    return ''.join([vowels_replace[i] if i in vowels else i for i in message])
Generated code:  def encode(message):
    vowels = "aeiouAEIOU"
    vowels_replace = dict([(i, chr(ord(i) + 2)) for i in vowels])
    message = message.swapcase()
    return ''.join([vowels_replace[i] if i in vowels else i for i in message])
Retrieved Documents:  ['\n\ndef func_0(lst):\n    \n\n    def func_1(n):\n        for i in range(2,int(n**0.5)+1):\n            if n%i==0:\n                return False\n\n        return True\n    maxx = 0\n    i = 0\n    while i < len(lst):\n        if(lst[i] > maxx and isPrime(lst[i])):\n            maxx = lst[i]\n        i+=1\n    result = sum(int(digit) for digit in str(maxx))\n    return result\n\n']
Generated code:  def skjkasdkd(lst):
    def is_prime(n):
        if n <= 1:
            return False
        if n <= 3:
            return True
        if n % 2 == 0 or n % 3 == 0:
            return False
        i = 5
        while i * i <= n:
            if n % i == 0 or n % (i + 2) == 0:
                return False
            i += 6
        return True

    max_prime = 0
    for num in lst:
        if num > max_prime and is_prime(num):
            max_prime = num

    return sum(int(digit) for digit in str(max_prime))
Generated code:  def skjkasdkd(lst):
    def is_prime(n):
        if n < 2:
            return False
        for i in range(2, int(n**0.5) + 1):
            if n % i == 0:
                return False
        return True

    max_prime = 0
    for num in lst:
        if num > max_prime and is_prime(num):
            max_prime = num

    return sum(int(digit) for digit in str(max_prime))
Generated code:  def skjkasdkd(lst):
    def is_prime(n):
        if n < 2:
            return False
        for i in range(2, int(n**0.5) + 1):
            if n % i == 0:
                return False
        return True

    max_prime = 0
    for num in lst:
        if is_prime(num) and num > max_prime:
            max_prime = num

    return sum(int(digit) for digit in str(max_prime))
Retrieved Documents:  ['\ndef func_0(dict):\n    \n\n    if len(dict.keys()) == 0:\n        return False\n    else:\n        state = "start"\n        for key in dict.keys():\n\n            if isinstance(key, str) == False:\n                state = "mixed"\n                break\n            if state == "start":\n                if key.isupper():\n                    state = "upper"\n                elif key.islower():\n                    state = "lower"\n                else:\n                    break\n            elif (state == "upper" and not key.isupper()) or (state == "lower" and not key.islower()):\n                    state = "mixed"\n                    break\n            else:\n                break\n        return state == "upper" or state == "lower" \n']
Generated code:  def check_dict_case(dictionary):
    if not dictionary:
        return False
    lower_case = upper_case = False
    for key in dictionary.keys():
        if not isinstance(key, str):
            return False
        if key.islower():
            lower_case = True
        elif key.isupper():
            upper_case = True
        else:
            return False
        if lower_case and upper_case:
            return False
    return True
Generated code:  def check_dict_case(dict):
    if not dict:
        return False
    lower = upper = None
    for key in dict.keys():
        if not isinstance(key, str):
            return False
        if lower is None and upper is None:
            lower = key.islower()
            upper = key.isupper()
        elif lower and not key.islower():
            return False
        elif upper and not key.isupper():
            return False
    return True
Generated code:  def check_dict_case(dictionary):
    if not dictionary:
        return False
    lower_case = upper_case = None
    for key in dictionary.keys():
        if not isinstance(key, str):
            return False
        if lower_case is None and upper_case is None:
            lower_case = key.islower()
            upper_case = key.isupper()
        else:
            if lower_case and not key.islower():
                return False
            if upper_case and not key.isupper():
                return False
    return True
Retrieved Documents:  ['\ndef func_0(n):\n    \n\n    primes = []\n    for i in range(2, n):\n        is_prime = True\n        for j in range(2, i):\n            if i % j == 0:\n                is_prime = False\n                break\n        if is_prime:\n            primes.append(i)\n    return primes\n\n']
Generated code:  def count_up_to(n):
    primes = []
    for i in range(2, n):
        is_prime = True
        for j in range(2, i):
            if i % j == 0:
                is_prime = False
                break
        if is_prime:
            primes.append(i)
    return primes
Generated code:  def count_up_to(n):
    primes = []
    for i in range(2, n):
        is_prime = True
        for j in range(2, i):
            if i % j == 0:
                is_prime = False
                break
        if is_prime:
            primes.append(i)
    return primes
Generated code:  def count_up_to(n):
    primes = []
    for i in range(2, n):
        is_prime = True
        for j in range(2, i):
            if i % j == 0:
                is_prime = False
                break
        if is_prime:
            primes.append(i)
    return primes
Retrieved Documents:  ['\n\ndef func_0(a: int, b: int) -> int:\n    \n\n    while b:\n        a, b = b, a % b\n    return a\n']
Generated code:  def multiply(a: int, b: int) -> int:
    return (abs(a) % 10) * (abs(b) % 10)
Generated code:  def multiply(a, b):
    return (abs(a) % 10) * (abs(b) % 10)
Generated code:  def multiply(a, b):
    return abs(a % 10) * abs(b % 10)
Retrieved Documents:  ['def func_0(string, vowels): \r\n    final = [each for each in string if each in vowels] \r\n    return(len(final)) \r\n']
Generated code:  def count_upper(s):
    """
    Given a string s, count the number of uppercase vowels in even indices.
    
    For example:
    count_upper('aBCdEf') returns 1
    count_upper('abcdefg') returns 0
    count_upper('dBBE') returns 0
    """
    vowels = 'AEIOU'
    count = 0
    for i in range(0, len(s), 2):
        if s[i] in vowels:
            count += 1
    return count
Generated code:  def count_upper(s):
    """
    Given a string s, count the number of uppercase vowels in even indices.
    
    For example:
    count_upper('aBCdEf') returns 1
    count_upper('abcdefg') returns 0
    count_upper('dBBE') returns 0
    """
    vowels = "AEIOU"
    count = 0
    for i in range(0, len(s), 2):
        if s[i] in vowels:
            count += 1
    return count
Generated code:  def count_upper(s):
    """
    Given a string s, count the number of uppercase vowels in even indices.
    
    For example:
    count_upper('aBCdEf') returns 1
    count_upper('abcdefg') returns 0
    count_upper('dBBE') returns 0
    """
    vowels = "AEIOU"
    count = 0
    for i in range(0, len(s), 2):
        if s[i] in vowels:
            count += 1
    return count
Retrieved Documents:  ["\ndef func_0(value):\n    \n\n    from math import floor, ceil\n\n    if value.count('.') == 1:\n        # remove trailing zeros\n        while (value[-1] == '0'):\n            value = value[:-1]\n\n    num = float(value)\n    if value[-2:] == '.5':\n        if num > 0:\n            res = ceil(num)\n        else:\n            res = floor(num)\n    elif len(value) > 0:\n        res = int(round(num))\n    else:\n        res = 0\n\n    return res\n\n"]
Generated code:  def closest_integer(value):
    num = float(value)
    if value.endswith('.5'):
        return int(num + 0.5) if num > 0 else int(num - 0.5)
    else:
        return round(num)
Generated code:  def closest_integer(value):
    num = float(value)
    if value[-2:] == '.5':
        if num > 0:
            res = int(num) + 1
        else:
            res = int(num) - 1
    else:
        res = round(num)
    return res
Generated code:  def closest_integer(value):
    '''
    Create a function that takes a value (string) representing a number
    and returns the closest integer to it. If the number is equidistant
    from two integers, round it away from zero.

    Examples
    >>> closest_integer("10")
    10
    >>> closest_integer("15.3")
    15

    Note:
    Rounding away from zero means that if the given number is equidistant
    from two integers, the one you should return is the one that is the
    farthest from zero. For example closest_integer("14.5") should
    return 15 and closest_integer("-14.5") should return -15.
    '''

    from math import floor, ceil

    if value.count('.') == 1:
        # remove trailing zeros
        while (value[-1] == '0'):
            value = value[:-1]

    num = float(value)
    if value[-2:] == '.5':
        if num > 0:
            res = ceil(num)
        else:
            res = floor(num)
    elif len(value) > 0:
        res = int(round(num))
    else:
        res = 0

    return res
Retrieved Documents:  ['\ndef func_0(n):\n    \n\n    if n%2==0:\n        odd_collatz = [] \n    else:\n        odd_collatz = [n]\n    while n > 1:\n        if n % 2 == 0:\n            n = n/2\n        else:\n            n = n*3 + 1\n            \n        if n%2 == 1:\n            odd_collatz.append(int(n))\n\n    return sorted(odd_collatz)\n']
Generated code:  def make_a_pile(n):
    pile = [n]
    for i in range(n-1):
        if n % 2 == 0:
            n += 2
        else:
            n += 2
        pile.append(n)
    return pile
Generated code:  def make_a_pile(n):
    stones = [n]
    for i in range(1, n):
        stones.append(stones[-1] + (1 if n % 2 else 2))
    return stones
Generated code:  def make_a_pile(n):
    """
    Given a positive integer n, you have to make a pile of n levels of stones.
    The first level has n stones.
    The number of stones in the next level is:
        - the next odd number if n is odd.
        - the next even number if n is even.
    Return the number of stones in each level in a list, where element at index
    i represents the number of stones in the level (i+1).

    Examples:
    >>> make_a_pile(3)
    [3, 5, 7]
    """
    stones = [n]
    for i in range(n-1):
        if n % 2 == 0:
            stones.append(stones[-1] + 2)
        else:
            stones.append(stones[-1] + 2)
    return stones
Retrieved Documents:  ['\ndef func_0(s):\n    \n\n    if not s:\n        return []\n\n    s_list = []\n\n    for letter in s:\n        if letter == \',\':\n            s_list.append(\' \')\n        else:\n            s_list.append(letter)\n\n    s_list = "".join(s_list)\n    return s_list.split()\n']
Generated code:  def words_string(s):
    """
    You will be given a string of words separated by commas or spaces. Your task is
    to split the string into words and return an array of the words.
    
    For example:
    words_string("Hi, my name is John") == ["Hi", "my", "name", "is", "John"]
    words_string("One, two, three, four, five, six") == ["One", "two", "three", "four", "five", "six"]
    """
    return s.replace(',','').split()
Generated code:  def words_string(s):
    return s.replace(',','').split()
Generated code:  def words_string(s):
    return s.split()
Retrieved Documents:  ['def func_0(nums):\r\n even_nums = list(filter(lambda x: x%2 == 0, nums))\r\n return even_nums']
Generated code:  def choose_num(x, y):
    """This function takes two positive numbers x and y and returns the
    biggest even integer number that is in the range [x, y] inclusive. If 
    there's no such number, then the function should return -1.

    For example:
    choose_num(12, 15) = 14
    choose_num(13, 12) = -1
    """
    if x > y:
        return -1
    for num in range(y, x-1, -1):
        if num % 2 == 0:
            return num
    return -1
Generated code:  def choose_num(x, y):
    if x > y:
        return -1
    elif y % 2 == 0:
        return y
    elif (y - 1) >= x:
        return y - 1
    else:
        return -1
Generated code:  def choose_num(x, y):
    if x > y:
        return -1
    if y % 2 == 0:
        return y
    if x == y:
        return -1
    return y - 1
Retrieved Documents:  ['\ndef func_0(n, m):\n    \n\n    if m < n:\n        return -1\n    summation = 0\n    for i in range(n, m+1):\n        summation += i\n    return bin(round(summation/(m - n + 1)))\n']
Generated code:  def rounded_avg(n, m):
    if n > m:
        return -1
    avg = round((n + m) / 2)
    return bin(avg)
Generated code:  def rounded_avg(n, m):
    if n > m:
        return -1
    avg = round((n + m) / 2)
    return bin(avg)
Generated code:  def rounded_avg(n, m):
    if m < n:
        return -1
    summation = 0
    for i in range(n, m+1):
        summation += i
    return bin(round(summation/(m - n + 1)))
Retrieved Documents:  ['\ndef func_0(x):\n    \n\n    odd_digit_elements = []\n    for i in x:\n        if all (int(c) % 2 == 1 for c in str(i)):\n            odd_digit_elements.append(i)\n    return sorted(odd_digit_elements)\n']
Generated code:  def unique_digits(x):
    """Given a list of positive integers x. return a sorted list of all 
    elements that hasn't any even digit.

    Note: Returned list should be sorted in increasing order.
    
    For example:
    >>> unique_digits([15, 33, 1422, 1])
    [1, 15, 33]
    >>> unique_digits([152, 323, 1422, 10])
    []
    """
    odd_digit_elements = []
    for i in x:
        if all (int(c) % 2 == 1 for c in str(i)):
            odd_digit_elements.append(i)
    return sorted(odd_digit_elements)
Generated code:  def unique_digits(x):
    odd_digit_elements = []
    for i in x:
        if all (int(c) % 2 == 1 for c in str(i)):
            odd_digit_elements.append(i)
    return sorted(odd_digit_elements)
Generated code:  def unique_digits(x):
    odd_digit_elements = []
    for i in x:
        if all (int(c) % 2 == 1 for c in str(i)):
            odd_digit_elements.append(i)
    return sorted(odd_digit_elements)
Retrieved Documents:  ['def func_0(array_nums):\r\n  result = sorted(array_nums, key = lambda i: 0 if i == 0 else -1 / i)\r\n  return result ']
Generated code:  def by_length(arr):
    # Filter the array to include only numbers between 1 and 9
    filtered_arr = [num for num in arr if 1 <= num <= 9]
    
    # Sort the filtered array in ascending order
    sorted_arr = sorted(filtered_arr)
    
    # Reverse the sorted array
    reversed_arr = sorted_arr[::-1]
    
    # Map each number in the reversed array to its corresponding name
    named_arr = [str(num) for num in reversed_arr]
    
    return named_arr
Generated code:  def by_length(arr):
    # Filter out numbers not between 1 and 9
    filtered_arr = [num for num in arr if 1 <= num <= 9]
    
    # Sort the filtered array
    filtered_arr.sort()
    
    # Reverse the sorted array
    filtered_arr.reverse()
    
    # Map the numbers to their corresponding names
    name_map = {
        1: "One",
        2: "Two",
        3: "Three",
        4: "Four",
        5: "Five",
        6: "Six",
        7: "Seven",
        8: "Eight",
        9: "Nine",
    }
    result = [name_map[num] for num in filtered_arr]
    
    return result
Generated code:  def by_length(arr):
    """
    Given an array of integers, sort the integers that are between 1 and 9 inclusive,
    reverse the resulting array, and then replace each digit by its corresponding name from
    "One", "Two", "Three", "Four", "Five", "Six", "Seven", "Eight", "Nine".

    For example:
      arr = [2, 1, 1, 4, 5, 8, 2, 3]   
            -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] 
            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]
      return ["Eight", "Five", "Four", "Three", "Two", "Two", "One", "One"]
    
      If the array is empty, return an empty array:
      arr = []
      return []
    
      If the array has any strange number ignore it:
      arr = [1, -1, 55] 
            -> sort arr -> [-1, 1, 55]
            -> reverse arr -> [55, 1, -1]
      return = ['One']
    """

    # Filter the array to include only numbers between 1 and 9
    filtered_arr = [num for num in arr if 1 <= num <= 9]

    # Sort the filtered array in descending order
    sorted_arr = sorted(filtered_arr, reverse=True)

    # Map each number to its corresponding name
    name_arr = [str(num) for num in sorted_arr]

    return name_arr
Retrieved Documents:  ['def func_0(start,end): \r\n    res = 1 \r\n    for i in range(start,end + 1): \r\n        res *= i      \r\n    return res \r\ndef func_1(n): \r\n   return int(factorial(n + 1, 2 * n)  /factorial(1, n)) ']
Generated code:  def f(n):
    result = []
    for i in range(1, n + 1):
        if i % 2 == 0:
            result.append(factorial(i))
        else:
            result.append(sum(range(1, i + 1)))
    return result
Generated code:  def f(n):
    factorial = 1
    sum = 0
    result = []
    for i in range(1, n + 1):
        if i % 2 == 0:
            factorial *= i
            result.append(factorial)
        else:
            sum += i
            result.append(sum)
    return result
Generated code:  def f(n):
    def factorial(n):
        if n == 0:
            return 1
        else:
            return n * factorial(n-1)
    
    result = []
    for i in range(1, n+1):
        if i % 2 == 0:
            result.append(factorial(i))
        else:
            result.append(sum(range(1, i+1)))
    return result
Retrieved Documents:  ['\ndef func_0(n):\n    \n\n    def func_1(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n']
Generated code:  def even_odd_palindrome(n):
    even_palindrome_count = 0
    odd_palindrome_count = 0

    for i in range(1, n+1):
        if str(i) == str(i)[::-1]:
            if i % 2 == 0:
                even_palindrome_count += 1
            else:
                odd_palindrome_count += 1
    return (even_palindrome_count, odd_palindrome_count)
Generated code:  def even_odd_palindrome(n):
    even_palindrome_count = 0
    odd_palindrome_count = 0

    for i in range(1, n+1):
        if str(i) == str(i)[::-1]:
            if i%2 == 0:
                even_palindrome_count += 1
            else:
                odd_palindrome_count += 1
    return (even_palindrome_count, odd_palindrome_count)
Generated code:  def even_odd_palindrome(n):
    even_palindrome_count = 0
    odd_palindrome_count = 0

    for i in range(1, n+1):
        if str(i) == str(i)[::-1]:
            if i%2 == 0:
                even_palindrome_count += 1
            else:
                odd_palindrome_count += 1
    return (even_palindrome_count, odd_palindrome_count)
Retrieved Documents:  ['\ndef func_0(nums):\n    \n\n    \n    count = 0\n    for num in nums:\n        if num > 10:\n            odd_digits = (1, 3, 5, 7, 9)\n            number_as_string = str(num)\n            if int(number_as_string[0]) in odd_digits and int(number_as_string[-1]) in odd_digits:\n                count += 1\n        \n    return count \n']
Generated code:  def count_nums(arr):
    """
    Write a function count_nums which takes an array of integers and returns
    the number of elements which has a sum of digits > 0.
    If a number is negative, then its first signed digit will be negative:
    e.g. -123 has signed digits -1, 2, and 3.
    >>> count_nums([]) == 0
    >>> count_nums([-1, 11, -11]) == 1
    >>> count_nums([1, 1, 2]) == 3
    """
    count = 0
    for num in arr:
        if num > 0:
            count += 1
        else:
            digits_sum = sum(int(digit) for digit in str(num)[1:]) - int(str(num)[1])
            if digits_sum > 0:
                count += 1
    return count
Generated code:  def count_nums(arr):
    count = 0
    for num in arr:
        if num > 0:
            count += 1
    return count
Generated code:  def count_nums(arr):
    """
    Write a function count_nums which takes an array of integers and returns
    the number of elements which has a sum of digits > 0.
    If a number is negative, then its first signed digit will be negative:
    e.g. -123 has signed digits -1, 2, and 3.
    >>> count_nums([]) == 0
    >>> count_nums([-1, 11, -11]) == 1
    >>> count_nums([1, 1, 2]) == 3
    """
    def sum_of_digits(n):
        if n < 0:
            n = -n
            n = str(n)
            n = list(n)
            n[0] = '-' + n[0]
            n = ''.join(n)
            n = int(n)
        else:
            n = str(n)
            n = list(n)
            n = ''.join(n)
            n = int(n)
        return sum(int(digit) for digit in str(n))
    
    return len([num for num in arr if sum_of_digits(num) > 0])
Retrieved Documents:  ['def func_0(arr, n, out_of_place, cur):\r\n\ttemp = arr[cur]\r\n\tfor i in range(cur, out_of_place, -1):\r\n\t\tarr[i] = arr[i - 1]\r\n\tarr[out_of_place] = temp\r\n\treturn arr\r\ndef func_1(arr, n):\r\n\tout_of_place = -1\r\n\tfor index in range(n):\r\n\t\tif (out_of_place >= 0):\r\n\t\t\tif ((arr[index] >= 0 and arr[out_of_place] < 0) or\r\n\t\t\t(arr[index] < 0 and arr[out_of_place] >= 0)):\r\n\t\t\t\tarr = right_rotate(arr, n, out_of_place, index)\r\n\t\t\t\tif (index-out_of_place > 2):\r\n\t\t\t\t\tout_of_place += 2\r\n\t\t\t\telse:\r\n\t\t\t\t\tout_of_place = - 1\r\n\t\tif (out_of_place == -1):\r\n\t\t\tif ((arr[index] >= 0 and index % 2 == 0) or\r\n\t\t\t (arr[index] < 0 and index % 2 == 1)):\r\n\t\t\t\tout_of_place = index\r\n\treturn arr']
Generated code:  def move_one_ball(arr):
    if not arr:
        return True
    n = len(arr)
    for i in range(n):
        if arr[i] > arr[(i + 1) % n]:
            return False
    return True
Generated code:  def move_one_ball(arr):
    if not arr:
        return True
    sorted_arr = sorted(arr)
    for i in range(len(arr)):
        if arr[i:] + arr[:i] == sorted_arr:
            return True
    return False
Generated code:  def move_one_ball(arr):
    if not arr:
        return True
    sorted_arr = sorted(arr)
    for i in range(len(arr)):
        if arr[i:] + arr[:i] == sorted_arr:
            return True
    return False
Retrieved Documents:  ['\ndef func_0(lst1, lst2):\n    \n\n    odd = 0\n    even = 0\n    for i in lst1:\n        if i%2 == 1:\n            odd += 1\n    for i in lst2:\n        if i%2 == 0:\n            even += 1\n    if even >= odd:\n        return "YES"\n    return "NO"\n            \n']
Generated code:  def exchange(lst1, lst2):
    odd_count = sum(1 for num in lst1 if num % 2!= 0)
    even_count = sum(1 for num in lst2 if num % 2 == 0)
    return "YES" if even_count >= odd_count else "NO"
Generated code:  def exchange(lst1, lst2):
    odd_count = sum(1 for num in lst1 if num % 2!= 0)
    even_count = sum(1 for num in lst2 if num % 2 == 0)
    return "YES" if even_count >= odd_count else "NO"
Generated code:  def exchange(lst1, lst2):
    odd_lst1 = sum(1 for num in lst1 if num % 2!= 0)
    even_lst2 = sum(1 for num in lst2 if num % 2 == 0)
    return "YES" if even_lst2 >= odd_lst1 else "NO"
Retrieved Documents:  ["def func_0(text,n):\r\n  words = re.findall('\\w+',text)\r\n  func_0= Counter(words).most_common(n)\r\n  return list(func_0)"]
Generated code:  from collections import Counter
import re

def histogram(test):
    words = re.findall('\w+', test)
    counts = Counter(words)
    max_count = max(counts.values(), default=0)
    return {word: count for word, count in counts.items() if count == max_count}
Generated code:  from collections import Counter

def histogram(test):
    if not test:
        return {}
    words = test.split()
    counts = Counter(words)
    max_count = max(counts.values())
    return {word: count for word, count in counts.items() if count == max_count}
Generated code:  from collections import Counter

def histogram(test):
    words = test.split()
    counts = Counter(words)
    max_count = max(counts.values())
    return {word: count for word, count in counts.items() if count == max_count}
Retrieved Documents:  ["\ndef func_0(s,c):\n    \n\n    s = ''.join([char for char in s if char not in c])\n    return (s,s[::-1] == s)\n"]
Generated code:  def reverse_delete(s, c):
    s = ''.join([char for char in s if char not in c])
    return (s, s == s[::-1])
Generated code:  def reverse_delete(s, c):
    s = ''.join([char for char in s if char not in c])
    return (s, s == s[::-1])
Generated code:  def reverse_delete(s, c):
    s = ''.join([char for char in s if char not in c])
    return (s, s == s[::-1])
Retrieved Documents:  ['\ndef func_0(lst):\n    \n\n    res = []\n    for arr in lst:\n        n = sum(int(d)%2==1 for d in arr)\n        res.append("the number of odd elements " + str(n) + "n the str"+ str(n) +"ng "+ str(n) +" of the "+ str(n) +"nput.")\n    return res\n']
Generated code:  def odd_count(lst):
    return ["the number of odd elements {}n the str{}ng {} of the {}nput.".format(sum(int(d)%2==1 for d in arr), sum(int(d)%2==1 for d in arr), sum(int(d)%2==1 for d in arr), sum(int(d)%2==1 for d in arr)) for arr in lst]
Generated code:  def odd_count(lst):
    res = []
    for arr in lst:
        n = sum(int(d)%2==1 for d in arr)
        res.append("the number of odd elements " + str(n) + "n the str"+ str(n) +"ng "+ str(n) +" of the "+ str(n) +"nput.")
    return res
Generated code:  def odd_count(lst):
    res = []
    for arr in lst:
        n = sum(int(d)%2==1 for d in arr)
        res.append("the number of odd elements " + str(n) + "n the str"+ str(n) +"ng "+ str(n) +" of the "+ str(n) +"nput.")
    return res
Retrieved Documents:  ['\ndef func_0(nums):\n    \n\n    max_sum = 0\n    s = 0\n    for num in nums:\n        s += -num\n        if (s < 0):\n            s = 0\n        max_sum = max(s, max_sum)\n    if max_sum == 0:\n        max_sum = max(-i for i in nums)\n    min_sum = -max_sum\n    return min_sum\n']
Generated code:  def minSubArraySum(nums):
    min_sum = float('inf')
    current_sum = 0
    for num in nums:
        current_sum = min(num, current_sum + num)
        min_sum = min(min_sum, current_sum)
    return min_sum
Generated code:  def minSubArraySum(nums):
    min_sum = float('inf')
    current_sum = 0
    for num in nums:
        current_sum += num
        if current_sum < min_sum:
            min_sum = current_sum
        if current_sum > 0:
            current_sum = 0
    return min_sum
Generated code:  def minSubArraySum(nums):
    min_sum = float('inf')
    current_sum = 0
    for num in nums:
        current_sum += num
        if current_sum < min_sum:
            min_sum = current_sum
        if current_sum > 0:
            current_sum = 0
    return min_sum
Retrieved Documents:  ['\ndef func_0(grid, capacity):\n    import math\n    \n\n    return sum([math.ceil(sum(arr)/capacity) for arr in grid])\n']
Generated code:  def max_fill(grid, capacity):
    return sum([(row.count(1) + capacity - 1) // capacity for row in grid])
Generated code:  def max_fill(grid, capacity):
    import math
    return sum([math.ceil(sum(arr)/capacity) for arr in grid])
Generated code:  def max_fill(grid, capacity):
    import math
    return sum([math.ceil(sum(arr)/capacity) for arr in grid])
Retrieved Documents:  ['def func_0(array_nums):\r\n  result = sorted(array_nums, key = lambda i: 0 if i == 0 else -1 / i)\r\n  return result ']
Generated code:  def sort_array(arr):
    return sorted(arr, key=lambda x: (bin(x).count('1'), x))
Generated code:  def sort_array(arr):
    return sorted(arr, key=lambda x: (bin(x).count('1'), x))
Generated code:  def sort_array(arr):
    return sorted(arr, key=lambda x: (bin(x).count('1'), x))
Retrieved Documents:  ['\ndef func_0(s, n):\n    \n\n    result = []\n    for word in s.split():\n        n_consonants = 0\n        for i in range(0, len(word)):\n            if word[i].lower() not in ["a","e","i","o","u"]:\n                n_consonants += 1 \n        if n_consonants == n:\n            result.append(word)\n    return result\n\n']
Generated code:  def select_words(s, n):
    """Given a string s and a natural number n, you have been tasked to implement 
    a function that returns a list of all words from string s that contain exactly 
    n consonants, in order these words appear in the string s.
    If the string s is empty then the function should return an empty list.
    Note: you may assume the input string contains only letters and spaces.
    Examples:
    select_words("Mary had a little lamb", 4) ==> ["little"]
    select_words("Mary had a little lamb", 3) ==> ["Mary", "lamb"]
    select_words("simple white space", 2) ==> []
    select_words("Hello world", 4) ==> ["world"]
    select_words("Uncle sam", 3) ==> ["Uncle"]
    """

    result = []
    for word in s.split():
        n_consonants = 0
        for i in range(0, len(word)):
            if word[i].lower() not in ["a","e","i","o","u"]:
                n_consonants += 1 
        if n_consonants == n:
            result.append(word)
    return result
Generated code:  def select_words(s, n):
    """Given a string s and a natural number n, you have been tasked to implement 
    a function that returns a list of all words from string s that contain exactly 
    n consonants, in order these words appear in the string s.
    If the string s is empty then the function should return an empty list.
    Note: you may assume the input string contains only letters and spaces.
    Examples:
    select_words("Mary had a little lamb", 4) ==> ["little"]
    select_words("Mary had a little lamb", 3) ==> ["Mary", "lamb"]
    select_words("simple white space", 2) ==> []
    select_words("Hello world", 4) ==> ["world"]
    select_words("Uncle sam", 3) ==> ["Uncle"]
    """

    result = []
    for word in s.split():
        n_consonants = 0
        for i in range(0, len(word)):
            if word[i].lower() not in ["a","e","i","o","u"]:
                n_consonants += 1 
        if n_consonants == n:
            result.append(word)
    return result
Generated code:  def select_words(s, n):
    """Given a string s and a natural number n, you have been tasked to implement 
    a function that returns a list of all words from string s that contain exactly 
    n consonants, in order these words appear in the string s.
    If the string s is empty then the function should return an empty list.
    Note: you may assume the input string contains only letters and spaces.
    Examples:
    select_words("Mary had a little lamb", 4) ==> ["little"]
    select_words("Mary had a little lamb", 3) ==> ["Mary", "lamb"]
    select_words("simple white space", 2) ==> []
    select_words("Hello world", 4) ==> ["world"]
    select_words("Uncle sam", 3) ==> ["Uncle"]
    """

    result = []
    for word in s.split():
        n_consonants = 0
        for i in range(0, len(word)):
            if word[i].lower() not in ["a","e","i","o","u"]:
                n_consonants += 1 
        if n_consonants == n:
            result.append(word)
    return result
Retrieved Documents:  ['\ndef func_0(word):\n    \n\n    if len(word) < 3:\n        return ""\n\n    vowels = {"a", "e", "i", "o", "u", "A", "E", \'O\', \'U\', \'I\'}\n    for i in range(len(word)-2, 0, -1):\n        if word[i] in vowels:\n            if (word[i+1] not in vowels) and (word[i-1] not in vowels):\n                return word[i]\n    return ""\n']
Generated code:  def get_closest_vowel(word):
    vowels = "aeiouAEIOU"
    for i in range(len(word) - 2, 0, -1):
        if word[i] in vowels and word[i-1] not in vowels and word[i+1] not in vowels:
            return word[i]
    return ""
Generated code:  def get_closest_vowel(word):
    vowels = "aeiouAEIOU"
    for i in range(len(word)-2, 0, -1):
        if word[i] in vowels and word[i+1] not in vowels and word[i-1] not in vowels:
            return word[i]
    return ""
Generated code:  def get_closest_vowel(word):
    vowels = "aeiouAEIOU"
    for i in range(len(word) - 2, 0, -1):
        if word[i] in vowels and word[i+1] not in vowels and word[i-1] not in vowels:
            return word[i]
    return ""
Retrieved Documents:  ["\ndef func_0(lst):\n    \n\n    def func_1(s):\n        val = 0\n        for i in s:\n            if i == '(':\n                val = val + 1\n            else:\n                val = val - 1\n            if val < 0:\n                return False\n        return True if val == 0 else False\n\n    S1 = lst[0] + lst[1]\n    S2 = lst[1] + lst[0]\n    return 'Yes' if check(S1) or check(S2) else 'No'\n"]
Generated code:  def match_parens(lst):
    def is_balanced(s):
        balance = 0
        for char in s:
            if char == '(':
                balance += 1
            elif char == ')':
                balance -= 1
            if balance < 0:
                return False
        return balance == 0

    first_combination = lst[0] + lst[1]
    second_combination = lst[1] + lst[0]
    return 'Yes' if is_balanced(first_combination) or is_balanced(second_combination) else 'No'
Generated code:  def match_parens(lst):
    '''
    You are given a list of two strings, both strings consist of open
    parentheses '(' or close parentheses ')' only.
    Your job is to check if it is possible to concatenate the two strings in
    some order, that the resulting string will be good.
    A string S is considered to be good if and only if all parentheses in S
    are balanced. For example: the string '(())()' is good, while the string
    '())' is not.
    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.

    Examples:
    match_parens(['()(', ')']) == 'Yes'
    match_parens([')', ')']) == 'No'
    '''

    def is_balanced(s):
        balance = 0
        for char in s:
            if char == '(':
                balance += 1
            elif char == ')':
                balance -= 1
            if balance < 0:
                return False
        return balance == 0

    first_combination = lst[0] + lst[1]
    second_combination = lst[1] + lst[0]
    if is_balanced(first_combination) or is_balanced(second_combination):
        return 'Yes'
    else:
        return 'No'
Generated code:  def match_parens(lst):
    def is_balanced(s):
        balance = 0
        for char in s:
            if char == '(':
                balance += 1
            elif char == ')':
                balance -= 1
            if balance < 0:
                return False
        return balance == 0

    first_combination = lst[0] + lst[1]
    second_combination = lst[1] + lst[0]
    return 'Yes' if is_balanced(first_combination) or is_balanced(second_combination) else 'No'
Retrieved Documents:  ['def func_0(arr,n,k): \r\n    max1 = max(arr) \r\n    res = 0\r\n    for i in range(0,n):  \r\n        if ((max1 - arr[i]) % k != 0): \r\n            return -1 \r\n        else: \r\n            res += (max1 - arr[i]) / k \r\n    return int(res) ']
Generated code:  def maximum(arr, k):
    arr.sort(reverse=True)
    return arr[:k]
Generated code:  def maximum(arr, k):
    arr.sort()
    return arr[-k:]
Generated code:  def maximum(arr, k):
    arr.sort(reverse=True)
    return arr[:k]
Retrieved Documents:  ['\ndef func_0(lst):\n    \n\n    res = []\n    for arr in lst:\n        n = sum(int(d)%2==1 for d in arr)\n        res.append("the number of odd elements " + str(n) + "n the str"+ str(n) +"ng "+ str(n) +" of the "+ str(n) +"nput.")\n    return res\n']
Generated code:  def solution(lst):
    return sum(x for i, x in enumerate(lst) if i % 2 == 0 and x % 2 == 1)
Generated code:  def solution(lst):
    return sum(x for i, x in enumerate(lst) if i % 2 == 1 and x % 2 == 1)
Generated code:  def solution(lst):
    return sum(lst[i] for i in range(0, len(lst), 2) if lst[i] % 2!= 0)
Retrieved Documents:  ['\ndef func_0(arr, k):\n    \n\n    return sum(elem for elem in arr[:k] if len(str(elem)) <= 2)\n']
Generated code:  def add_elements(arr, k):
    return sum(elem for elem in arr[:k] if len(str(elem)) <= 2)
Generated code:  def add_elements(arr, k):
    return sum(elem for elem in arr[:k] if len(str(elem)) <= 2)
Generated code:  def add_elements(arr, k):
    return sum(elem for elem in arr[:k] if len(str(elem)) <= 2)
Retrieved Documents:  ['\ndef func_0(n):\n    \n\n    if n%2==0:\n        odd_collatz = [] \n    else:\n        odd_collatz = [n]\n    while n > 1:\n        if n % 2 == 0:\n            n = n/2\n        else:\n            n = n*3 + 1\n            \n        if n%2 == 1:\n            odd_collatz.append(int(n))\n\n    return sorted(odd_collatz)\n']
Generated code:  def get_odd_collatz(n):
    odd_collatz = []
    while n > 1:
        if n % 2 == 1:
            odd_collatz.append(n)
        n = 3 * n + 1 if n % 2 else n // 2
    odd_collatz.append(1)
    return sorted(odd_collatz)
Generated code:  def get_odd_collatz(n):
    odd_collatz = []
    while n > 1:
        if n % 2 == 0:
            n = n / 2
        else:
            odd_collatz.append(n)
            n = 3 * n + 1
    odd_collatz.append(1)
    return sorted(odd_collatz)
Generated code:  def get_odd_collatz(n):
    odd_collatz = []
    while n > 1:
        if n % 2 == 0:
            n = n / 2
        else:
            odd_collatz.append(n)
            n = 3 * n + 1
    odd_collatz.append(1)
    return sorted(odd_collatz)
Retrieved Documents:  ["\ndef func_0(date):\n    \n\n    try:\n        date = date.strip()\n        month, day, year = date.split('-')\n        month, day, year = int(month), int(day), int(year)\n        if month < 1 or month > 12:\n            return False\n        if month in [1,3,5,7,8,10,12] and day < 1 or day > 31:\n            return False\n        if month in [4,6,9,11] and day < 1 or day > 30:\n            return False\n        if month == 2 and day < 1 or day > 29:\n            return False\n    except:\n        return False\n\n    return True\n"]
Generated code:  def valid_date(date):
    """You have to write a function which validates a given date string and
    returns True if the date is valid otherwise False.
    The date is valid if all of the following rules are satisfied:
    1. The date string is not empty.
    2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.
    3. The months should not be less than 1 or higher than 12.
    4. The date should be in the format: mm-dd-yyyy

    for example: 
    valid_date('03-11-2000') => True

    valid_date('15-01-2012') => False

    valid_date('04-0-2040') => False

    valid_date('06-04-2020') => True

    valid_date('06/04/2020') => False
    """
    if not date:
        return False
    parts = date.split('-')
    if len(parts)!= 3:
        return False
    month, day, year = parts
    if not month.isdigit() or not day.isdigit() or not year.isdigit():
        return False
    month, day, year = int(month), int(day), int(year)
    if month < 1 or month > 12:
        return False
    if month in [1,3,5,7,8,10,12] and day < 1 or day > 31:
        return False
    if month in [4,6,9,11] and day < 1 or day > 30:
        return False
    if month == 2 and day < 1 or day > 29:
        return False
    return True
Generated code:  def valid_date(date):
    try:
        date = date.strip()
        month, day, year = date.split('-')
        month, day, year = int(month), int(day), int(year)
        if month < 1 or month > 12:
            return False
        if month in [1,3,5,7,8,10,12] and day < 1 or day > 31:
            return False
        if month in [4,6,9,11] and day < 1 or day > 30:
            return False
        if month == 2 and day < 1 or day > 29:
            return False
    except:
        return False

    return True
Generated code:  def valid_date(date):
    """You have to write a function which validates a given date string and
    returns True if the date is valid otherwise False.
    The date is valid if all of the following rules are satisfied:
    1. The date string is not empty.
    2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.
    3. The months should not be less than 1 or higher than 12.
    4. The date should be in the format: mm-dd-yyyy

    for example: 
    valid_date('03-11-2000') => True

    valid_date('15-01-2012') => False

    valid_date('04-0-2040') => False

    valid_date('06-04-2020') => True

    valid_date('06/04/2020') => False
    """

    try:
        date = date.strip()
        month, day, year = date.split('-')
        month, day, year = int(month), int(day), int(year)
        if month < 1 or month > 12:
            return False
        if month in [1,3,5,7,8,10,12] and day < 1 or day > 31:
            return False
        if month in [4,6,9,11] and day < 1 or day > 30:
            return False
        if month == 2 and day < 1 or day > 29:
            return False
    except:
        return False

    return True
Retrieved Documents:  ['\ndef func_0(txt):\n    \n\n    if " " in txt:\n        return txt.split()\n    elif "," in txt:\n        return txt.replace(\',\',\' \').split()\n    else:\n        return len([i for i in txt if i.islower() and ord(i)%2 == 0])\n']
Generated code:  def split_words(txt):
    if " " in txt:
        return txt.split()
    elif "," in txt:
        return txt.replace(',',' ').split()
    else:
        return len([i for i in txt if i.islower() and ord(i)%2 == 0])
Generated code:  def split_words(txt):
    if " " in txt:
        return txt.split()
    elif "," in txt:
        return txt.replace(',',' ').split()
    else:
        return len([i for i in txt if i.islower() and ord(i)%2 == 0])
Generated code:  def split_words(txt):
    if " " in txt:
        return txt.split()
    elif "," in txt:
        return txt.replace(',',' ').split()
    else:
        return len([i for i in txt if i.islower() and ord(i)%2 == 0])
Retrieved Documents:  ['def func_0(nums):\r\n    if (sorted(nums)== nums):\r\n        return True\r\n    else:\r\n        return False']
Generated code:  def is_sorted(lst):
    if len(lst) == 1:
        return True
    for i in range(len(lst) - 1):
        if lst[i] > lst[i + 1]:
            return False
    return True
Generated code:  def is_sorted(lst):
    if len(lst) == 1:
        return True
    for i in range(len(lst) - 1):
        if lst[i] > lst[i + 1]:
            return False
    return True
Generated code:  def is_sorted(lst):
    if len(lst) < 2:
        return True
    for i in range(1, len(lst)):
        if lst[i-1] > lst[i]:
            return False
    return True
Retrieved Documents:  ['\ndef func_0(interval1, interval2):\n    \n\n    def func_1(num):\n        if num == 1 or num == 0:\n            return False\n        if num == 2:\n            return True\n        for i in range(2, num):\n            if num%i == 0:\n                return False\n        return True\n\n    l = max(interval1[0], interval2[0])\n    r = min(interval1[1], interval2[1])\n    length = r - l\n    if length > 0 and is_prime(length):\n        return "YES"\n    return "NO"\n']
Generated code:  def intersection(interval1, interval2):
    def is_prime(n):
        if n <= 1:
            return False
        if n == 2:
            return True
        if n % 2 == 0:
            return False
        for i in range(3, int(n**0.5) + 1, 2):
            if n % i == 0:
                return False
        return True

    start = max(interval1[0], interval2[0])
    end = min(interval1[1], interval2[1])
    if start <= end:
        length = end - start + 1
        if is_prime(length):
            return "YES"
    return "NO"
Generated code:  def intersection(interval1, interval2):
    l = max(interval1[0], interval2[0])
    r = min(interval1[1], interval2[1])
    length = r - l
    if length > 0 and is_prime(length):
        return "YES"
    return "NO"

def is_prime(n):
    if n == 1 or n == 0:
        return False
    if n == 2:
        return True
    for i in range(2, n):
        if n%i == 0:
            return False
    return True
Generated code:  def intersection(interval1, interval2):
    l = max(interval1[0], interval2[0])
    r = min(interval1[1], interval2[1])
    length = r - l
    if length > 0 and is_prime(length):
        return "YES"
    return "NO"

def is_prime(n):
    if n == 1 or n == 0:
        return False
    if n == 2:
        return True
    for i in range(2, n):
        if n%i == 0:
            return False
    return True
Retrieved Documents:  ['\ndef func_0(arr):\n    \n\n    if not arr: return None\n    prod = 0 if 0 in arr else (-1) ** len(list(filter(lambda x: x < 0, arr)))\n    return prod * sum([abs(i) for i in arr])\n']
Generated code:  def prod_signs(arr):
    if not arr: return None
    prod = (-1) ** sum(1 for x in arr if x < 0)
    return prod * sum(abs(i) for i in arr)
Generated code:  def prod_signs(arr):
    if not arr: return None
    prod = (-1) ** sum(1 for x in arr if x < 0)
    return prod * sum(abs(i) for i in arr)
Generated code:  def prod_signs(arr):
    if not arr: return None
    prod = (-1) ** sum(1 for x in arr if x < 0)
    return prod * sum(abs(i) for i in arr)
Retrieved Documents:  ['\ndef func_0(grid, k):\n    \n\n    n = len(grid)\n    val = n * n + 1\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                temp = []\n                if i != 0:\n                    temp.append(grid[i - 1][j])\n\n                if j != 0:\n                    temp.append(grid[i][j - 1])\n\n                if i != n - 1:\n                    temp.append(grid[i + 1][j])\n\n                if j != n - 1:\n                    temp.append(grid[i][j + 1])\n\n                val = min(temp)\n\n    ans = []\n    for i in range(k):\n        if i % 2 == 0:\n            ans.append(1)\n        else:\n            ans.append(val)\n    return ans\n']
Generated code:  def minPath(grid, k):
    n = len(grid)
    visited = [[False] * n for _ in range(n)]
    path = []
    
    def dfs(x, y, k):
        if k == 0:
            path.append(grid[x][y])
            return True
        
        visited[x][y] = True
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        
        for dx, dy in directions:
            nx, ny = x + dx, y + dy
            if 0 <= nx < n and 0 <= ny < n and not visited[nx][ny]:
                if dfs(nx, ny, k - 1):
                    path.append(grid[x][y])
                    return True
        
        visited[x][y] = False
        return False
    
    dfs(0, 0, k - 1)
    path.reverse()
    return path
Generated code:  def minPath(grid, k):
    n = len(grid)
    dp = [[[float('inf') for _ in range(k + 1)] for _ in range(n)] for _ in range(n)]
    for i in range(n):
        for j in range(n):
            dp[i][j][0] = 0
    for l in range(1, k + 1):
        for i in range(n):
            for j in range(n):
                for x, y in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:
                    if 0 <= x < n and 0 <= y < n:
                        dp[i][j][l] = min(dp[i][j][l], dp[x][y][l - 1] + (grid[i][j]!= grid[x][y]))
    return [grid[i][j] for i, j in sorted(zip(*[[i, j] for i in range(n) for j in range(n) if dp[i][j][k] == min(dp[i][j])]))]
Generated code:  def minPath(grid, k):
    n = len(grid)
    dp = [[[float('inf')] * (k + 1) for _ in range(n)] for _ in range(n)]
    for i in range(n):
        for j in range(n):
            dp[i][j][0] = 0
    for l in range(1, k + 1):
        for i in range(n):
            for j in range(n):
                for x, y in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
                    ni, nj = i + x, j + y
                    if 0 <= ni < n and 0 <= nj < n:
                        dp[i][j][l] = min(dp[i][j][l], dp[ni][nj][l - 1] + abs(grid[i][j] - grid[ni][nj]))
    min_val = min(dp[i][j][k] for i in range(n) for j in range(n))
    path = []
    for i in range(n):
        for j in range(n):
            if dp[i][j][k] == min_val:
                path.append(grid[i][j])
                break
    return path
Retrieved Documents:  ['\ndef func_0(n):\n    \n\n    if n == 0:\n        return [1]\n    my_tri = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            my_tri.append(i / 2 + 1)\n        else:\n            my_tri.append(my_tri[i - 1] + my_tri[i - 2] + (i + 3) / 2)\n    return my_tri\n']
Generated code:  def tri(n):
    if n == 0:
        return [1]
    my_tri = [1, 3]
    for i in range(2, n + 1):
        if i % 2 == 0:
            my_tri.append(i / 2 + 1)
        else:
            my_tri.append(my_tri[i - 1] + my_tri[i - 2] + (i + 3) / 2)
    return my_tri
Generated code:  def tri(n):
    if n == 0:
        return [1]
    my_tri = [1, 3]
    for i in range(2, n + 1):
        if i % 2 == 0:
            my_tri.append(i / 2 + 1)
        else:
            my_tri.append(my_tri[i - 1] + my_tri[i - 2] + (i + 3) / 2)
    return my_tri
Generated code:  def tri(n):
    if n == 0:
        return [3]
    my_tri = [3, 2]
    for i in range(2, n + 1):
        if i % 2 == 0:
            my_tri.append(i / 2 + 1)
        else:
            my_tri.append(my_tri[i - 1] + my_tri[i - 2] + (i + 3) / 2)
    return my_tri
Retrieved Documents:  ['\ndef func_0(n):\n    \n\n    product = 1\n    odd_count = 0\n    for digit in str(n):\n        int_digit = int(digit)\n        if int_digit%2 == 1:\n            product= product*int_digit\n            odd_count+=1\n    if odd_count ==0:\n        return 0\n    else:\n        return product\n']
Generated code:  def digits(n):
    product = 1
    odd_count = 0
    for digit in str(n):
        int_digit = int(digit)
        if int_digit % 2 == 1:
            product *= int_digit
            odd_count += 1
    if odd_count == 0:
        return 0
    else:
        return product
Generated code:  def digits(n):
    product = 1
    odd_count = 0
    for digit in str(n):
        int_digit = int(digit)
        if int_digit % 2 == 1:
            product *= int_digit
            odd_count += 1
    if odd_count == 0:
        return 0
    else:
        return product
Generated code:  def digits(n):
    product = 1
    odd_count = 0
    for digit in str(n):
        int_digit = int(digit)
        if int_digit%2 == 1:
            product= product*int_digit
            odd_count+=1
    if odd_count ==0:
        return 0
    else:
        return product
Retrieved Documents:  ["\ndef func_0(string):\n    \n\n    opening_bracket_index = []\n    closing_bracket_index = []\n    for i in range(len(string)):\n        if string[i] == '[':\n            opening_bracket_index.append(i)\n        else:\n            closing_bracket_index.append(i)\n    closing_bracket_index.reverse()\n    cnt = 0\n    i = 0\n    l = len(closing_bracket_index)\n    for idx in opening_bracket_index:\n        if i < l and idx < closing_bracket_index[i]:\n            cnt += 1\n            i += 1\n    return cnt >= 2\n\n    \n"]
Generated code:  def is_nested(string):
    stack = []
    for char in string:
        if char == '[':
            stack.append(char)
        elif char == ']' and stack:
            stack.pop()
    return len(stack) > 0
Generated code:  def is_nested(string):
    stack = []
    for char in string:
        if char == '[':
            stack.append(char)
        elif char == ']' and stack:
            stack.pop()
        else:
            return False
    return len(stack) > 0
Generated code:  def is_nested(string):
    stack = []
    for char in string:
        if char == '[':
            stack.append(char)
        elif char == ']' and stack:
            stack.pop()
        else:
            return False
    return len(stack) > 0
Retrieved Documents:  ['\n\ndef func_0(lst):\n    \n\n    import math\n    squared = 0\n    for i in lst:\n        squared += math.ceil(i)**2\n    return squared\n']
Generated code:  def sum_squares(lst):
    return sum(math.ceil(i)**2 for i in lst)
Generated code:  def sum_squares(lst):
    return sum(map(lambda x: int(x**2 + 0.5), lst))
Generated code:  def sum_squares(lst):
    return sum(map(lambda x: int(x**2), map(math.ceil, lst)))
Retrieved Documents:  ["\ndef func_0(txt):\n    \n\n \n    check = txt.split(' ')[-1]\n    return True if len(check) == 1 and (97 <= ord(check.lower()) <= 122) else False\n"]
Generated code:  def check_if_last_char_is_a_letter(txt):
    '''
    Create a function that returns True if the last character
    of a given string is an alphabetical character and is not
    a part of a word, and False otherwise.
    Note: "word" is a group of characters separated by space.

    Examples:
    check_if_last_char_is_a_letter("apple pie")  False
    check_if_last_char_is_a_letter("apple pi e")  True
    check_if_last_char_is_a_letter("apple pi e ")  False
    check_if_last_char_is_a_letter("")  False 
    '''
    if not txt:
        return False
    last_char = txt[-1]
    if not last_char.isalpha():
        return False
    if len(txt) == 1:
        return True
    second_last_char = txt[-2]
    return second_last_char ==''
Generated code:  def check_if_last_char_is_a_letter(txt):
    if not txt or not txt[-1].isalpha():
        return False
    return txt[-2].isspace()
Generated code:  def check_if_last_char_is_a_letter(txt):
    if not txt or not txt[-1].isalpha():
        return False
    return txt[-2].isspace() if txt[-2]!= "" else True
Retrieved Documents:  ["def func_0(arr, number):\r\n  arr.sort()\r\n  if number > arr[-1]:\r\n    return ('Yes, the entered number is greater than those in the array')\r\n  else:\r\n    return ('No, entered number is less than those in the array')"]
Generated code:  def can_arrange(arr):
    for i in range(len(arr) - 1, 0, -1):
        if arr[i] < arr[i - 1]:
            return i
    return -1
Generated code:  def can_arrange(arr):
    for i in range(len(arr) - 1, 0, -1):
        if arr[i] < arr[i - 1]:
            return i
    return -1
Generated code:  def can_arrange(arr):
    for i in range(len(arr)-1, 0, -1):
        if arr[i] < arr[i-1]:
            return i
    return -1
Retrieved Documents:  ['\ndef func_0(lst):\n    \n\n    smallest = list(filter(lambda x: x < 0, lst))\n    largest = list(filter(lambda x: x > 0, lst))\n    return (max(smallest) if smallest else None, min(largest) if largest else None)\n']
Generated code:  def largest_smallest_integers(lst):
    negatives = [x for x in lst if x < 0]
    positives = [x for x in lst if x > 0]
    return (max(negatives) if negatives else None, min(positives) if positives else None)
Generated code:  def largest_smallest_integers(lst):
    negatives = [x for x in lst if x < 0]
    positives = [x for x in lst if x > 0]
    return (max(negatives) if negatives else None, min(positives) if positives else None)
Generated code:  def largest_smallest_integers(lst):
    negatives = [x for x in lst if x < 0]
    positives = [x for x in lst if x > 0]
    return (max(negatives) if negatives else None, min(positives) if positives else None)
Retrieved Documents:  ["\ndef func_0(a, b):\n    \n\n    temp_a, temp_b = a, b\n    if isinstance(temp_a, str): temp_a = temp_a.replace(',','.')\n    if isinstance(temp_b, str): temp_b = temp_b.replace(',','.')\n    if float(temp_a) == float(temp_b): return None\n    return a if float(temp_a) > float(temp_b) else b \n"]
Generated code:  def compare_one(a, b):
    if isinstance(a, str): a = a.replace(',', '.')
    if isinstance(b, str): b = b.replace(',', '.')
    if float(a) == float(b): return None
    return a if float(a) > float(b) else b
Generated code:  def compare_one(a, b):
    if isinstance(a, str):
        a = float(a.replace(',', '.'))
    if isinstance(b, str):
        b = float(b.replace(',', '.'))
    if a == b:
        return None
    return a if a > b else b
Generated code:  def compare_one(a, b):
    if isinstance(a, str):
        a = a.replace(',', '.')
    if isinstance(b, str):
        b = b.replace(',', '.')
    if float(a) == float(b):
        return None
    return a if float(a) > float(b) else b
Retrieved Documents:  ['def func_0 (arr,n,p): \r\n    _sum = 0\r\n    for i in range(n): \r\n        _sum = _sum + arr[i] \r\n    if p == 1: \r\n        if _sum % 2 == 0: \r\n            return "ODD"\r\n        else: \r\n            return "EVEN"\r\n    return "EVEN"\r\n      ']
Generated code:  def is_equal_to_sum_even(n):
    return n % 2 == 0 and n >= 8
Generated code:  def is_equal_to_sum_even(n):
    return n % 4 == 0
Generated code:  def is_equal_to_sum_even(n):
    return n % 8 == 0
Retrieved Documents:  ['def func_0(n):\r\n    if (n<=2):\r\n      return n\r\n    i = n * 2\r\n    factors = [number  for number in range(n, 1, -1) if number * 2 > n]\r\n    while True:\r\n        for a in factors:\r\n            if i % a != 0:\r\n                i += n\r\n                break\r\n            if (a == factors[-1] and i % a == 0):\r\n                return i']
Generated code:  def special_factorial(n):
    factorial = 1
    for i in range(1, n + 1):
        factorial *= i
    return factorial
Generated code:  def special_factorial(n):
    factorial = 1
    for i in range(1, n + 1):
        factorial *= i
    return factorial
Generated code:  def special_factorial(n):
    factorial = 1
    for i in range(1, n + 1):
        factorial *= i
    return factorial
Retrieved Documents:  ['def func_0(str1):\r\n    result = tuple(x for x in str1 if not x.isspace()) \r\n    return result']
Generated code:  def fix_spaces(text):
    result = []
    consecutive_spaces = 0
    for char in text:
        if char == " ":
            consecutive_spaces += 1
        else:
            if consecutive_spaces > 2:
                result.append("-")
            elif consecutive_spaces > 0:
                result.extend(["_"] * consecutive_spaces)
            result.append(char)
            consecutive_spaces = 0
    if consecutive_spaces > 2:
        result.append("-")
    elif consecutive_spaces > 0:
        result.extend(["_"] * consecutive_spaces)
    return "".join(result)
Generated code:  def fix_spaces(text):
    result = []
    space_count = 0
    for char in text:
        if char == " ":
            space_count += 1
        else:
            if space_count > 2:
                result.append("-")
            elif space_count > 0:
                result.extend(["_"] * space_count)
            result.append(char)
            space_count = 0
    if space_count > 2:
        result.append("-")
    elif space_count > 0:
        result.extend(["_"] * space_count)
    return "".join(result)
Generated code:  def fix_spaces(text):
    result = []
    consecutive_spaces = 0
    for char in text:
        if char == " ":
            consecutive_spaces += 1
        else:
            if consecutive_spaces > 2:
                result.append("-")
            elif consecutive_spaces > 0:
                result.extend(["_"] * consecutive_spaces)
            result.append(char)
            consecutive_spaces = 0
    if consecutive_spaces > 2:
        result.append("-")
    elif consecutive_spaces > 0:
        result.extend(["_"] * consecutive_spaces)
    return "".join(result)
Retrieved Documents:  ["\ndef func_0(file_name):\n    \n\n    suf = ['txt', 'exe', 'dll']\n    lst = file_name.split(sep='.')\n    if len(lst) != 2:\n        return 'No'\n    if not lst[1] in suf:\n        return 'No'\n    if len(lst[0]) == 0:\n        return 'No'\n    if not lst[0][0].isalpha():\n        return 'No'\n    t = len([x for x in lst[0] if x.isdigit()])\n    if t > 3:\n        return 'No'\n    return 'Yes'\n"]
Generated code:  def file_name_check(file_name):
    """Create a function which takes a string representing a file's name, and returns
    'Yes' if the the file's name is valid, and returns 'No' otherwise.
    A file's name is considered to be valid if and only if all the following conditions 
    are met:
    - There should not be more than three digits ('0'-'9') in the file's name.
    - The file's name contains exactly one dot '.'
    - The substring before the dot should not be empty, and it starts with a letter from 
    the latin alphapet ('a'-'z' and 'A'-'Z').
    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']
    Examples:
    file_name_check("example.txt") # => 'Yes'
    file_name_check("1example.dll") # => 'No' (the name should start with a latin alphapet letter)
    """
    valid_extensions = ['txt', 'exe', 'dll']
    parts = file_name.split('.')
    
    # Check if there is exactly one dot in the file name
    if len(parts)!= 2:
        return 'No'
    
    # Check if the file name starts with a letter
    if not parts[0][0].isalpha():
        return 'No'
    
    # Check if the file name contains more than three digits
    if len([char for char in parts[0] if char.isdigit()]) > 3:
        return 'No'
    
    # Check if the file extension is valid
    if parts[1] not in valid_extensions:
        return 'No'
    
    return 'Yes'
Generated code:  def file_name_check(file_name):
    """Create a function which takes a string representing a file's name, and returns
    'Yes' if the the file's name is valid, and returns 'No' otherwise.
    A file's name is considered to be valid if and only if all the following conditions 
    are met:
    - There should not be more than three digits ('0'-'9') in the file's name.
    - The file's name contains exactly one dot '.'
    - The substring before the dot should not be empty, and it starts with a letter from 
    the latin alphapet ('a'-'z' and 'A'-'Z').
    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']
    Examples:
    file_name_check("example.txt") # => 'Yes'
    file_name_check("1example.dll") # => 'No' (the name should start with a latin alphapet letter)
    """

    suf = ['txt', 'exe', 'dll']
    lst = file_name.split(sep='.')
    if len(lst)!= 2:
        return 'No'
    if not lst[1] in suf:
        return 'No'
    if len(lst[0]) == 0:
        return 'No'
    if not lst[0][0].isalpha():
        return 'No'
    t = len([x for x in lst[0] if x.isdigit()])
    if t > 3:
        return 'No'
    return 'Yes'
Generated code:  def file_name_check(file_name):
    """Create a function which takes a string representing a file's name, and returns
    'Yes' if the the file's name is valid, and returns 'No' otherwise.
    A file's name is considered to be valid if and only if all the following conditions 
    are met:
    - There should not be more than three digits ('0'-'9') in the file's name.
    - The file's name contains exactly one dot '.'
    - The substring before the dot should not be empty, and it starts with a letter from 
    the latin alphapet ('a'-'z' and 'A'-'Z').
    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']
    Examples:
    file_name_check("example.txt") # => 'Yes'
    file_name_check("1example.dll") # => 'No' (the name should start with a latin alphapet letter)
    """

    suf = ['txt', 'exe', 'dll']
    lst = file_name.split(sep='.')
    if len(lst)!= 2:
        return 'No'
    if not lst[1] in suf:
        return 'No'
    if len(lst[0]) == 0:
        return 'No'
    if not lst[0][0].isalpha():
        return 'No'
    t = len([x for x in lst[0] if x.isdigit()])
    if t > 3:
        return 'No'
    return 'Yes'
Retrieved Documents:  ['\n\n\ndef func_0(lst):\n    \n\n    result =[]\n    for i in range(len(lst)):\n        if i %3 == 0:\n            result.append(lst[i]**2)\n        elif i % 4 == 0 and i%3 != 0:\n            result.append(lst[i]**3)\n        else:\n            result.append(lst[i])\n    return sum(result)\n']
Generated code:  def sum_squares(lst):
    return sum(x**2 if i % 3 == 0 else x**3 if i % 4 == 0 and i % 3!= 0 else x for i, x in enumerate(lst))
Generated code:  def sum_squares(lst):
    result = []
    for i in range(len(lst)):
        if i % 3 == 0:
            result.append(lst[i] ** 2)
        elif i % 4 == 0 and i % 3!= 0:
            result.append(lst[i] ** 3)
        else:
            result.append(lst[i])
    return sum(result)
Generated code:  def sum_squares(lst):
    result = []
    for i, num in enumerate(lst):
        if i % 3 == 0:
            result.append(num ** 2)
        elif i % 4 == 0 and i % 3!= 0:
            result.append(num ** 3)
        else:
            result.append(num)
    return sum(result)
Retrieved Documents:  ['\ndef func_0(sentence):\n    \n\n    new_lst = []\n    for word in sentence.split():\n        flg = 0\n        if len(word) == 1:\n            flg = 1\n        for i in range(2, len(word)):\n            if len(word)%i == 0:\n                flg = 1\n        if flg == 0 or len(word) == 2:\n            new_lst.append(word)\n    return " ".join(new_lst)\n']
Generated code:  def words_in_sentence(sentence):
    def is_prime(n):
        if n <= 1:
            return False
        for i in range(2, int(n**0.5) + 1):
            if n % i == 0:
                return False
        return True

    return''.join(word for word in sentence.split() if is_prime(len(word)))
Generated code:  def words_in_sentence(sentence):
    def is_prime(n):
        if n <= 1:
            return False
        for i in range(2, int(n**0.5) + 1):
            if n % i == 0:
                return False
        return True

    new_lst = [word for word in sentence.split() if is_prime(len(word))]
    return " ".join(new_lst)
Generated code:  def words_in_sentence(sentence):
    """
    You are given a string representing a sentence,
    the sentence contains some words separated by a space,
    and you have to return a string that contains the words from the original sentence,
    whose lengths are prime numbers,
    the order of the words in the new string should be the same as the original one.

    Example 1:
        Input: sentence = "This is a test"
        Output: "is"

    Example 2:
        Input: sentence = "lets go for swimming"
        Output: "go for"

    Constraints:
        * 1 <= len(sentence) <= 100
        * sentence contains only letters
    """
    def is_prime(n):
        if n <= 1:
            return False
        for i in range(2, int(n**0.5) + 1):
            if n % i == 0:
                return False
        return True

    words = sentence.split()
    prime_length_words = [word for word in words if is_prime(len(word))]
    return''.join(prime_length_words)
Retrieved Documents:  ['\ndef func_0(x, n):\n    \n\n    a, b = x.split("/")\n    c, d = n.split("/")\n    numerator = int(a) * int(c)\n    denom = int(b) * int(d)\n    if (numerator/denom == int(numerator/denom)):\n        return True\n    return False\n']
Generated code:  def simplify(x, n):
    a, b = map(int, x.split("/"))
    c, d = map(int, n.split("/"))
    return (a * c) % (b * d) == 0
Generated code:  def simplify(x, n):
    a, b = map(int, x.split("/"))
    c, d = map(int, n.split("/"))
    return a * c % (b * d) == 0
Generated code:  def simplify(x, n):
    a, b = map(int, x.split("/"))
    c, d = map(int, n.split("/"))
    return a * c % (b * d) == 0
Retrieved Documents:  ['\ndef func_0(nums):\n    \n\n    def func_1(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return sorted(nums, key=func_1)\n']
Generated code:  def order_by_points(nums):
    return sorted(nums, key=lambda x: (sum(int(i) for i in str(abs(x))), nums.index(x)))
Generated code:  def order_by_points(nums):
    return sorted(nums, key=lambda x: (sum(int(i) for i in str(abs(x))), nums.index(x)))
Generated code:  def order_by_points(nums):
    def digit_sum(n):
        return sum(int(digit) for digit in str(abs(n)))
    return sorted(nums, key=digit_sum)
Retrieved Documents:  ['def func_0(nums):\r\n odd_nums = list(filter(lambda x: x%2 != 0, nums))\r\n return odd_nums']
Generated code:  def specialFilter(nums):
    def is_odd(n):
        return n % 2!= 0

    def is_first_last_odd(n):
        n = abs(n)
        return is_odd(int(str(n)[0])) and is_odd(int(str(n)[-1]))

    return sum(1 for num in nums if num > 10 and is_first_last_odd(num))
Generated code:  def specialFilter(nums):
    count = 0
    for num in nums:
        if num > 10:
            odd_digits = (1, 3, 5, 7, 9)
            number_as_string = str(num)
            if int(number_as_string[0]) in odd_digits and int(number_as_string[-1]) in odd_digits:
                count += 1
        
    return count
Generated code:  def specialFilter(nums):
    count = 0
    for num in nums:
        if num > 10:
            odd_digits = (1, 3, 5, 7, 9)
            number_as_string = str(num)
            if int(number_as_string[0]) in odd_digits and int(number_as_string[-1]) in odd_digits:
                count += 1
    return count
Retrieved Documents:  ['\ndef func_0(n):\n    \n\n    if n == 0:\n        return [1]\n    my_tri = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            my_tri.append(i / 2 + 1)\n        else:\n            my_tri.append(my_tri[i - 1] + my_tri[i - 2] + (i + 3) / 2)\n    return my_tri\n']
Generated code:  def get_max_triples(n):
    a = [i * i - i + 1 for i in range(1, n + 1)]
    count = 0
    for i in range(n):
        for j in range(i + 1, n):
            for k in range(j + 1, n):
                if (a[i] + a[j] + a[k]) % 3 == 0:
                    count += 1
    return count
Generated code:  def get_max_triples(n):
    a = [i * i - i + 1 for i in range(1, n + 1)]
    count = 0
    for i in range(n):
        for j in range(i + 1, n):
            for k in range(j + 1, n):
                if (a[i] + a[j] + a[k]) % 3 == 0:
                    count += 1
    return count
Generated code:  def get_max_triples(n):
    a = [i * i - i + 1 for i in range(1, n + 1)]
    count = 0
    for i in range(n):
        for j in range(i + 1, n):
            for k in range(j + 1, n):
                if (a[i] + a[j] + a[k]) % 3 == 0:
                    count += 1
    return count
Retrieved Documents:  ['\ndef func_0(planet1, planet2):\n    \n\n    planet_names = ("Mercury", "Venus", "Earth", "Mars", "Jupiter", "Saturn", "Uranus", "Neptune")\n    if planet1 not in planet_names or planet2 not in planet_names or planet1 == planet2:\n        return ()\n    planet1_index = planet_names.index(planet1)\n    planet2_index = planet_names.index(planet2)\n    if planet1_index < planet2_index:\n        return (planet_names[planet1_index + 1: planet2_index])\n    else:\n        return (planet_names[planet2_index + 1 : planet1_index])\n']
Generated code:  def bf(planet1, planet2):
    planets = ["Mercury", "Venus", "Earth", "Mars", "Jupiter", "Saturn", "Uranus", "Neptune"]
    if planet1 not in planets or planet2 not in planets or planet1 == planet2:
        return ()
    start, end = sorted([planets.index(planet1), planets.index(planet2)])
    return tuple(planets[start + 1: end])
Generated code:  def bf(planet1, planet2):
    planet_names = ("Mercury", "Venus", "Earth", "Mars", "Jupiter", "Saturn", "Uranus", "Neptune")
    if planet1 not in planet_names or planet2 not in planet_names or planet1 == planet2:
        return ()
    planet1_index = planet_names.index(planet1)
    planet2_index = planet_names.index(planet2)
    if planet1_index < planet2_index:
        return planet_names[planet1_index + 1: planet2_index]
    else:
        return planet_names[planet2_index + 1 : planet1_index]
Generated code:  def bf(planet1, planet2):
    planet_names = ("Mercury", "Venus", "Earth", "Mars", "Jupiter", "Saturn", "Uranus", "Neptune")
    if planet1 not in planet_names or planet2 not in planet_names or planet1 == planet2:
        return ()
    planet1_index = planet_names.index(planet1)
    planet2_index = planet_names.index(planet2)
    if planet1_index < planet2_index:
        return (planet_names[planet1_index + 1: planet2_index])
    else:
        return (planet_names[planet2_index + 1 : planet1_index])
Retrieved Documents:  ['\ndef func_0(lst):\n    \n\n    res = []\n    for arr in lst:\n        n = sum(int(d)%2==1 for d in arr)\n        res.append("the number of odd elements " + str(n) + "n the str"+ str(n) +"ng "+ str(n) +" of the "+ str(n) +"nput.")\n    return res\n']
Generated code:  def sorted_list_sum(lst):
    # Filter out strings with odd lengths
    even_length_strings = [s for s in lst if len(s) % 2 == 0]
    
    # Sort the list by length, then alphabetically
    even_length_strings.sort(key=lambda x: (len(x), x))
    
    return even_length_strings
Generated code:  def sorted_list_sum(lst):
    # Remove strings with odd lengths
    lst = [s for s in lst if len(s) % 2 == 0]
    
    # Sort the list by length, then alphabetically
    lst.sort(key=lambda x: (len(x), x))
    
    return lst
Generated code:  def sorted_list_sum(lst):
    lst = [s for s in lst if len(s) % 2 == 0]
    lst.sort()
    return lst
Retrieved Documents:  ['\ndef func_0(n, x, y):\n    \n\n    if n == 1:\n        return y\n    for i in range(2, n):\n        if n % i == 0:\n            return y\n            break\n    else:\n        return x\n']
Generated code:  def x_or_y(n, x, y):
    if n < 2:
        return y
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return y
    return x
Generated code:  def x_or_y(n, x, y):
    if n == 1:
        return y
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return y
            break
    else:
        return x
Generated code:  def x_or_y(n, x, y):
    if n == 1:
        return y
    for i in range(2, n):
        if n % i == 0:
            return y
            break
    else:
        return x
Retrieved Documents:  ['\ndef func_0(lst):\n    \n\n    res = []\n    for arr in lst:\n        n = sum(int(d)%2==1 for d in arr)\n        res.append("the number of odd elements " + str(n) + "n the str"+ str(n) +"ng "+ str(n) +" of the "+ str(n) +"nput.")\n    return res\n']
Generated code:  def double_the_difference(lst):
    return sum(x**2 for x in lst if x > 0 and x % 2 == 1)
Generated code:  def double_the_difference(lst):
    return sum(i**2 for i in lst if i > 0 and i % 2 == 1)
Generated code:  def double_the_difference(lst):
    return sum(i**2 for i in lst if i > 0 and i%2!= 0)
Retrieved Documents:  ['\ndef func_0(game,guess):\n    \n\n    return [abs(x-y) for x,y in zip(game,guess)]\n']
Generated code:  def compare(game, guess):
    return [abs(x - y) for x, y in zip(game, guess)]
Generated code:  def compare(game,guess):
    return [abs(x-y) for x,y in zip(game,guess)]
Generated code:  def compare(game,guess):
    return [abs(x-y) for x,y in zip(game,guess)]
Retrieved Documents:  ['\ndef func_0(class_name, extensions):\n    \n\n    strong = extensions[0]\n    my_val = len([x for x in extensions[0] if x.isalpha() and x.isupper()]) - len([x for x in extensions[0] if x.isalpha() and x.islower()])\n    for s in extensions:\n        val = len([x for x in s if x.isalpha() and x.isupper()]) - len([x for x in s if x.isalpha() and x.islower()])\n        if val > my_val:\n            strong = s\n            my_val = val\n\n    ans = class_name + "." + strong\n    return ans\n\n']
Generated code:  def Strongest_Extension(class_name, extensions):
    strongest = extensions[0]
    max_strength = sum(1 for c in strongest if c.isupper()) - sum(1 for c in strongest if c.islower())
    for extension in extensions[1:]:
        strength = sum(1 for c in extension if c.isupper()) - sum(1 for c in extension if c.islower())
        if strength > max_strength:
            strongest = extension
            max_strength = strength
    return f"{class_name}.{strongest}"
Generated code:  def Strongest_Extension(class_name, extensions):
    strongest_extension = extensions[0]
    max_strength = len([x for x in extensions[0] if x.isupper()]) - len([x for x in extensions[0] if x.islower()])
    
    for extension in extensions[1:]:
        strength = len([x for x in extension if x.isupper()]) - len([x for x in extension if x.islower()])
        if strength > max_strength:
            strongest_extension = extension
            max_strength = strength
    
    return f"{class_name}.{strongest_extension}"
Generated code:  def Strongest_Extension(class_name, extensions):
    strongest_extension = extensions[0]
    max_strength = len([x for x in extensions[0] if x.isupper()]) - len([x for x in extensions[0] if x.islower()])
    for extension in extensions:
        strength = len([x for x in extension if x.isupper()]) - len([x for x in extension if x.islower()])
        if strength > max_strength:
            strongest_extension = extension
            max_strength = strength
    return f"{class_name}.{strongest_extension}"
Retrieved Documents:  ['def func_0(sentence,word): \r\n    s = sentence.split(" ") \r\n    for i in s:  \r\n        if (i == word): \r\n            return True\r\n    return False']
Generated code:  def cycpattern_check(a, b):
    if b in a:
        return True
    else:
        for i in range(len(b)):
            b = b[1:] + b[0]
            if b in a:
                return True
        return False
Generated code:  def cycpattern_check(a, b):
    for i in range(len(b)):
        rotated_b = b[i:] + b[:i]
        if rotated_b in a:
            return True
    return False
Generated code:  def cycpattern_check(a, b):
    """You are given 2 words. You need to return True if the second word or any of its rotations is a substring in the first word
    cycpattern_check("abcd","abd") => False
    cycpattern_check("hello","ell") => True
    cycpattern_check("whassup","psus") => False
    cycpattern_check("abab","baa") => True
    cycpattern_check("efef","eeff") => False
    cycpattern_check("himenss","simen") => True

    """
    for i in range(len(b)):
        rotated_b = b[i:] + b[:i]
        if rotated_b in a:
            return True
    return False
Retrieved Documents:  ['\ndef func_0(num):\n    \n\n    even_count = 0\n    odd_count = 0\n    for i in str(abs(num)):\n        if int(i)%2==0:\n            even_count +=1\n        else:\n            odd_count +=1\n    return (even_count, odd_count)\n']
Generated code:  def even_odd_count(num):
    even_count = 0
    odd_count = 0
    for i in str(abs(num)):
        if int(i)%2==0:
            even_count +=1
        else:
            odd_count +=1
    return (even_count, odd_count)
Generated code:  def even_odd_count(num):
    even_count = 0
    odd_count = 0
    for i in str(abs(num)):
        if int(i)%2==0:
            even_count +=1
        else:
            odd_count +=1
    return (even_count, odd_count)
Generated code:  def even_odd_count(num):
    even_count = 0
    odd_count = 0
    for i in str(abs(num)):
        if int(i)%2==0:
            even_count +=1
        else:
            odd_count +=1
    return (even_count, odd_count)
Retrieved Documents:  ['def func_0( num):\r\n        val = [1000, 900, 500, 400,100, 90, 50, 40,10, 9, 5, 4,1]\r\n        syb = ["M", "CM", "D", "CD","C", "XC", "L", "XL","X", "IX", "V", "IV","I"]\r\n        roman_num = \'\'\r\n        i = 0\r\n        while  num > 0:\r\n            for _ in range(num // val[i]):\r\n                roman_num += syb[i]\r\n                num -= val[i]\r\n            i += 1\r\n        return roman_num']
Generated code:  def int_to_mini_roman(number):
    val = [1000, 900, 500, 400,100, 90, 50, 40,10, 9, 5, 4,1]
    syb = ["M", "CM", "D", "CD","C", "XC", "L", "XL","X", "IX", "V", "IV","I"]
    roman_num = ''
    i = 0
    while  number > 0:
        for _ in range(number // val[i]):
            roman_num += syb[i]
            number -= val[i]
        i += 1
    return roman_num
Generated code:  def int_to_mini_roman(number):
    val = [1000, 900, 500, 400,100, 90, 50, 40,10, 9, 5, 4,1]
    syb = ["M", "CM", "D", "CD","C", "XC", "L", "XL","X", "IX", "V", "IV","I"]
    roman_num = ''
    i = 0
    while  number > 0:
        for _ in range(number // val[i]):
            roman_num += syb[i]
            number -= val[i]
        i += 1
    return roman_num
Generated code:  def int_to_mini_roman(number):
    val = [1000, 900, 500, 400,100, 90, 50, 40,10, 9, 5, 4,1]
    syb = ["M", "CM", "D", "CD","C", "XC", "L", "XL","X", "IX", "V", "IV","I"]
    roman_num = ''
    i = 0
    while  number > 0:
        for _ in range(number // val[i]):
            roman_num += syb[i]
            number -= val[i]
        i += 1
    return roman_num
Retrieved Documents:  ['def func_0(a,b,c): \r\n    sqa = pow(a,2) \r\n    sqb = pow(b,2) \r\n    sqc = pow(c,2) \r\n    if (sqa == sqa + sqb or sqb == sqa + sqc or sqc == sqa + sqb): \r\n        return ("Right-angled Triangle") \r\n    elif (sqa > sqc + sqb or sqb > sqa + sqc or sqc > sqa + sqb): \r\n        return ("Obtuse-angled Triangle") \r\n    else: \r\n        return ("Acute-angled Triangle") ']
Generated code:  def right_angle_triangle(a, b, c):
    '''
    Given the lengths of the three sides of a triangle. Return True if the three
    sides form a right-angled triangle, False otherwise.
    A right-angled triangle is a triangle in which one angle is right angle or 
    90 degree.
    Example:
    right_angle_triangle(3, 4, 5) == True
    right_angle_triangle(1, 2, 3) == False
    '''
    sides = sorted([a, b, c])
    return sides[2]**2 == sides[0]**2 + sides[1]**2
Generated code:  def right_angle_triangle(a, b, c):
    return max(a, b, c)**2 == (min(a, b, c)**2 + (max(a, b, c) - min(a, b, c))**2)
Generated code:  def right_angle_triangle(a, b, c):
    '''
    Given the lengths of the three sides of a triangle. Return True if the three
    sides form a right-angled triangle, False otherwise.
    A right-angled triangle is a triangle in which one angle is right angle or 
    90 degree.
    Example:
    right_angle_triangle(3, 4, 5) == True
    right_angle_triangle(1, 2, 3) == False
    '''
    return a**2 + b**2 == c**2
Retrieved Documents:  ['\ndef func_0(words):\n    \n\n    return sorted(words, key = lambda x: (-len(set(x)), x))[0]\n']
Generated code:  def find_max(words):
    return sorted(words, key = lambda x: (-len(set(x)), x))[0]
Generated code:  def find_max(words):
    return sorted(words, key = lambda x: (-len(set(x)), x))[0]
Generated code:  def find_max(words):
    return sorted(words, key = lambda x: (-len(set(x)), x))[0]
Retrieved Documents:  ['\ndef func_0(number, need, remaining):\n    \n\n    if(need <= remaining):\n        return [ number + need , remaining-need ]\n    else:\n        return [ number + remaining , 0]\n']
Generated code:  def eat(number, need, remaining):
    if need <= remaining:
        return [number + need, remaining - need]
    else:
        return [number + remaining, 0]
Generated code:  def eat(number, need, remaining):
    if need <= remaining:
        return [number + need, remaining - need]
    else:
        return [number + remaining, 0]
Generated code:  def eat(number, need, remaining):
    if need <= remaining:
        return [number + need, remaining - need]
    else:
        return [number + remaining, 0]
Retrieved Documents:  ['\ndef func_0(operator, operand):\n    \n\n    expression = str(operand[0])\n    for oprt, oprn in zip(operator, operand[1:]):\n        expression+= oprt + str(oprn)\n    return eval(expression)\n']
Generated code:  def do_algebra(operator, operand):
    """
    Given two lists operator, and operand. The first list has basic algebra operations, and 
    the second list is a list of integers. Use the two given lists to build the algebric 
    expression and return the evaluation of this expression.

    The basic algebra operations:
    Addition ( + ) 
    Subtraction ( - ) 
    Multiplication ( * ) 
    Floor division ( // ) 
    Exponentiation ( ** ) 

    Example:
    operator['+', '*', '-']
    array = [2, 3, 4, 5]
    result = 2 + 3 * 4 - 5
    => result = 9

    Note:
        The length of operator list is equal to the length of operand list minus one.
        Operand is a list of of non-negative integers.
        Operator list has at least one operator, and operand list has at least two operands.

    """
    expression = str(operand[0])
    for oprt, oprn in zip(operator, operand[1:]):
        expression+= oprt + str(oprn)
    return eval(expression)
Generated code:  def do_algebra(operator, operand):
    result = operand[0]
    for oprt, oprn in zip(operator, operand[1:]):
        if oprt == '+':
            result += oprn
        elif oprt == '-':
            result -= oprn
        elif oprt == '*':
            result *= oprn
        elif oprt == '//':
            result //= oprn
        elif oprt == '**':
            result **= oprn
    return result
Generated code:  def do_algebra(operator, operand):
    expression = str(operand[0])
    for oprt, oprn in zip(operator, operand[1:]):
        expression += oprt + str(oprn)
    return eval(expression)
Retrieved Documents:  ["\ndef func_0(s):\n    \n\n    d = 'abcdefghijklmnopqrstuvwxyz'\n    out = ''\n    for c in s:\n        if c in d:\n            out += d[(d.index(c)+2*2) % 26]\n        else:\n            out += c\n    return out\n"]
Generated code:  def solve(s):
    if not any(c.isalpha() for c in s):
        return s[::-1]
    return ''.join(c.swapcase() if c.isalpha() else c for c in s)
Generated code:  def solve(s):
    if not any(c.isalpha() for c in s):
        return s[::-1]
    return ''.join(c.swapcase() if c.isalpha() else c for c in s)
Generated code:  def solve(s):
    if not s:
        return s
    result = ""
    for char in s:
        if char.isalpha():
            result += char.swapcase()
        else:
            result += char
    return result
Retrieved Documents:  ["\ndef func_0(text):\n    \n\n    import hashlib\n    return hashlib.md5(text.encode('ascii')).hexdigest() if text else None\n"]
Generated code:  import hashlib

def string_to_md5(text):
    """
    Given a string 'text', return its md5 hash equivalent string.
    If 'text' is an empty string, return None.

    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'
    """
    return hashlib.md5(text.encode('ascii')).hexdigest() if text else None
Generated code:  import hashlib

def string_to_md5(text):
    return hashlib.md5(text.encode('ascii')).hexdigest() if text else None
Generated code:  import hashlib

def string_to_md5(text):
    """
    Given a string 'text', return its md5 hash equivalent string.
    If 'text' is an empty string, return None.

    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'
    """
    return hashlib.md5(text.encode('ascii')).hexdigest() if text else None
Retrieved Documents:  ['\ndef func_0(a, b):\n    \n\n    lower = max(2, min(a, b))\n    upper = min(8, max(a, b))\n\n    return [i for i in range(lower, upper+1) if i % 2 == 0]\n']
Generated code:  def generate_integers(a, b):
    """
    Given two positive integers a and b, return the even digits between a
    and b, in ascending order.

    For example:
    generate_integers(2, 8) => [2, 4, 6, 8]
    generate_integers(8, 2) => [2, 4, 6, 8]
    generate_integers(10, 14) => []
    """
    return [i for i in range(min(a, b), max(a, b)+1) if i % 2 == 0]
Generated code:  def generate_integers(a, b):
    lower = min(a, b)
    upper = max(a, b)
    
    return [i for i in range(lower, upper+1) if i % 2 == 0]
Generated code:  def generate_integers(a, b):
    lower = min(a, b)
    upper = max(a, b)
    return [i for i in range(lower, upper+1) if i % 2 == 0]
